/ *!

JSZip v3.1.3 - Una clase de Javascript para generar y leer archivos zip
<http://stuartk.com/jszip>

(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
Doble licencia bajo la licencia MIT o GPLv3. Ver https://raw.github.com/Stuk/jszip/master/LICENSE.markdown.

    JSZip usa la biblioteca pako lanzada bajo la licencia MIT:
    https://github.com/nodeca/pako/blob/master/LICENSE
        * /
! function (a) {if ("object" == typeof export && "undefined"! = typeof module) module.exports = a (); else if ("function" == typeof define && define.amd) define ([], a ); else {var b; b = "undefined"! = typeof window? window: "undefined"! = typeof global? global: "undefined"! = typeof self? self: this, b.JSZip = a ()}} (function () {return function a (b, c, d) {function e (g, h) {if (! c [g]) {if (! b [g]) {var i = "function" == typeof require && require; if (! h && i) return i (g,! 0); if (f) return f (g,! 0); var j = new Error ("No se puede encontrar el módulo '" + g + "'"); throw j.code = "MODULE_NOT_FOUND", j} var k = c [g] = {exportaciones: {}}; b [g] [0] .call (k.exports, función (a) {var c = b [g ] [1] [a]; devuelve e (c? C: a)}, k, k.exports, a, b, c, d)} return c [g] .exports} para (var f = "function" == typeof require && require, g = 0;g <d.length; g ++) e (d [g]); return e} ({1: [function (a, b, c) {"use estricto"; var d = a ("./ utils"), e = a ("./ support"), f = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789 + / ="; c.encode = function (a) {para (var b, c, e, g, h, i, j, k = [], l = 0, m = a.length, n = m, o = "string"! == d.getTypeOf (a); l <a.length;) n = ml, o? (b = a [l ++], c = l <m? a [l ++]: 0, e = l <m? a [l ++]: 0) :( b = a.charCodeAt (l ++), c = l <m? a.charCodeAt (l ++): 0, e = l <m? A.charCodeAt (l ++): 0), g = b >> 2, h = (3 & b) << 4 | c >> 4, i = n> 1? (15 & c) << 2 | e >> 6: 64, j = n> 2? 63 & e: 64, k.push (f.charAt (g) + f.charAt (h) + f.charAt (i) + f.charAt (j) ); devuelve k.join ("")}, c.decode = function (a) {var b, c, d, g, h, i, j, k = 0, l = 0, m = "data:" ; if (a.substr (0, m.length) === m) arroja un nuevo error ("Entrada de base64 no válida, parece una url de datos"); a = a.reemplazar (/ [^ A-Za-z0-9 \ + \ / \ =] / g, ""); var n = 3 * a.length / 4; if (a.charAt (a.length-1) = == f.charAt (64) && n -, a.charAt (a.length-2) === f.charAt (64) && n -, n% 1! == 0) arrojar un nuevo error ("Base64 no válida input, longitud de contenido incorrecta. "); var o; for (o = e.uint8array? new Uint8Array (0 | n): new Array (0 | n); k <a.length;) g = f.indexOf (a .charAt (k ++)), h = f.indexOf (a.charAt (k ++)), i = f.indexOf (a.charAt (k ++)), j = f.indexOf (a.charAt (k ++)), b = g << 2 | h >> 4, c = (15 & h) << 4 | i >> 2, d = (3 & i) << 6 | j, o [l ++] = b, 64! == i && (o [l ++] = c), 64! == j && (o [l ++] = d); devuelve o}}, {"./ support": 30, "./ utils": 32}], 2: [function ( a, b, c) {"use estricto"; función d (a, b, c, d, e) {this.compressedSize = a, this.uncompressedSize = b, this.crc32 = c, this.compression = d, this.compressedContent = e} var e = a ("./ external"), f = a ("./stream/DataWorker"),g=a("./stream/DataLengthProbe"),h=a("./stream/Crc32Probe"),g=a("./stream/DataLengthProbe");d.prototype= {getContentWorker: function () {var a = new f (e.Promise.resolve (this.compressedContent)). pipe (this.compression.uncompressWorker ()). pipe (new g ("data_length")), b = this ; return a.on ("end", function () {if (this.streamInfo.data_length! == b.uncompressedSize) arroja un nuevo error ("Error: falta de coincidencia de tamaño de datos sin comprimir")}), a}, getCompressedWorker: function () {return new f (e.Promise.resolve (this.compressedContent)). withStreamInfo ("compressedSize", this.compressedSize) .withStreamInfo ("uncompressedSize", this.uncompressedSize) .withStreamInfo ("crc32", this.crc32 ) .withStreamInfo ("compresión", this.compression)}}, d.createWorkerFrom = function (a, b, c) {return a.pipe (new h) .pipe (new g ("uncompressedSize")). pipe (b.compressWorker (c)). pipe (new g ("compressedSize")). withStreamInfo ("compresión", b)}, b. export = d}, {"./ external": 6, "./ stream / Crc32Probe": 25, "./ stream / DataLengthProbe": 26, "./ stream / DataWorker": 27}], 3: [función (a, b, c) {"use estricto"; var d = a ("./ stream / GenericWorker"); c.STORE = {magic: "\ 0 \ 0", compressWorker: function (a) {return new d ("ALMACENAR compresión")}, descompressWorker: function () {return new d ("ALMACENAR descompresión")}}, c.DEFLATE = a ("./ flate")}, {"./ flate": 7 "./stream/GenericWorker":28}font>,4:[function(a,b,c){"use estricto"; función d () {for (var a, b = [], c = 0; c < 256; c ++) {a = c; para (var d = 0; d <8; d ++) a = 1 & a? 3988292384 ^ a >>> 1: a >>> 1;b [c] = a} return b} función e (a, b, c, d) {var e = h, f = d + c; a ^ = - 1; for (var g = d; g <f; g ++) a = a >>> 8 ^ e [255 & (a ^ b [g])]; devuelve a ^ -1} función f (a, b, c, d) {var e = h, f = d + c; a ^ = - 1; para (var g = d; g <f; g ++) a = a >>> 8 ^ e [255 & (a ^ b.charCodeAt (g))]; devuelve a ^ -1} var g = a ("./ utils"), h = d (); b.exports = function (a, b) {if ("undefined" == typeof a ||! a.length) return 0; var c = "cadena"! == g.getTypeOf (a); devuelve c? e (0 | b, a, a.length, 0): f (0 | b, a, a.length, 0)}}, { "./utils":32}font>,5:[function(a,b,c){"use estricto"; c.base64 =! 1, c.binary =! 1, c.dir =! 1, c. createFolders =! 0, c.date = null, c.compression = null, c.compressionOptions = null, c.comment = null, c.unixPermissions = null, c.dosPermissions = null}, {}], 6: [función (a, b, c) {"use estricto"; var d = nulo; d = "indefinido"! = tipo de Promesa? Promesa: a ("mentira"), b.exports = {Promesa: d}}, {mentira : 58}], 7:[function (a, b, c) {"use estricto"; función d (a, b) {h.call (this, "FlateWorker /" + a), this._pako = new f [a] ({raw: ! 0, nivel: b.level || -1}), this.meta = {}; var c = this; this._pako.onData = function (a) {c.push ({data: a, meta: c .meta})}} var e = "undefined"! = typeof Uint8Array && "undefined"! = typeof Uint16Array && "undefined"! = typeof Uint32Array, f = a ("pako"), g = a ("./ utils") , h = a ("./ stream / GenericWorker"), i = e? "uint8array": "array"; c.magic = "\ b \ 0", g.inherits (d, h), d.prototype. processChunk = function (a) {this.meta = a.meta, this._pako.push (g.transformTo (i, a.data) ,! 1)}, d.prototype.flush = function () {h.prototype .flush.call (this), this._pako.push ([] ,! 0)}, d.prototype.cleanUp = function () {h.prototype.cleanUp.call (this), this._pako = null}, c.compressWorker = function (a) {return new d ("Deflate ", a)}, c.uncompressWorker = function () {return new d (" Inflate ", {})}}, {" ./ stream / GenericWorker ": 28," ./ utils ": 32, pako: 59}], 8: [función (a, b, c) {"usar estricto"; función d (a, b, c, d) {f.call (this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = b, this.zipPlatform = c, this.encodeFileName = d, this.streamFiles = a, this.accumulate =! 1, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0 , this.entriesCount = 0, this.currentFile = null, this._sources = []} var e = a ("../ utils"), f = a ("../ stream / GenericWorker"), g = a ("../utf8"),h=a("../crc32"),i=a("../signature"),j=function(a,b){var c, d =" "; para (c = 0; c <b; c ++) d + = String.fromCharCode (255 & a), a >>> = 8; return d}, k = función (a, b) {var c = a; return a || (c = b? 16893: 33204), (65535 & c) << 16},l = función (a, b) {return 63 & (a || 0)}, m = función (a, b, c, d, f, m) {var n, o, p = a.file, q = a .compression, r = m! == g.utf8encode, s = e.transformTo ("string", m (p.name)), t = e.transformTo ("string", g.utf8encode (p.name)) , u = p.comment, v = e.transformTo ("string", m (u)), w = e.transformTo ("string", g.utf8encode (u)), x = t.length! == p .name.length, y = w.length! == u.length, z = "", A = "", B = "", C = p.dir, D = p.date, E = {crc32: 0 , comprimido Tamaño: 0, sin comprimir: 0}; b &&! c || (E.crc32 = a.crc32, E.compressedSize = a.compressedSize, E.uncompressedSize = a.uncompressedSize); var F = 0; b && (F | = 8), r ||! X &&! Y || (F | = 2048); var G = 0, H = 0; C && (G | = 16), "UNIX" === f? (H = 798, G | = k (p.unixPermissions, C)) :( H = 20, G | = l (p.dosPermissions, C)), n = D.getUTCHours (), n << = 6, n | = D. getUTCMinutes (), n << = 5, n | = D.getUTCSeconds () / 2, o = D.getUTCFullYear () - 1980, o << = 4, o | = D.getUTCMonth () + 1, o << = 5, o | = D.getUTCDate (), x && (A = j (1,1) + j (h (s), 4) + t, z + = "arriba" + j (A. longitud, 2) + A), y && (B = j (1,1) + j (h (v), 4) + w, z + = "uc" + j (B.length, 2) + B); var I = ""; I + = "\ n \ 0", I + = j (F, 2), I + = q.magic, I + = j (n, 2), I + = j (o, 2), I + = j (E.crc32,4), I + = j (E.compressedSize, 4), I + = j (E.uncompressedSize, 4) , I + = j (s.length, 2), I + = j (z.length, 2); var J = i.LOCAL_FILE_HEADER + I + s + z, K = i.CENTRAL_FILE_HEADER + j (H, 2) + I + j (v.length, 2) + "\ 0 \ 0 \ 0 \ 0" + j (G, 4) + j (d, 4) + s + z + v; return {fileRecord: J, dirRecord: K }}, n = función (a, b, c, d, f) {var g = "", h = e.transformTo ("string", f (d)); return g = i.CENTRAL_DIRECTORY_END + "\ 0 \ 0 \ 0 \ 0 "+ j (a, 2) + j (a, 2) + j (b, 4) + j (c, 4) + j (h.length, 2) + h}, o = función (a) {var b = ""; devuelve b = i.DATA_DESCRIPTOR + j (a.crc32,4) + j (a.compressedSize, 4) + j (a.uncompressedSize, 4)}; e.hereda (d, f), d.prototype.push = function (a) {var b = a.meta.percent || 0, c = this.entriesCount, d = this._sources.length; this.accumulate? this. contentBuffer.push (a) :( this.bytesWritten + = a.data.length, f.prototype.push.call (this, {data: a.data, meta: {currentFile: this.currentFile, percent: c? (b + 100 * (cd-1)) / c: 100}}))}, d.prototype.openedSource = function (a) {this.currentSourceOffset = this.bytesWritten, this.currentFile = a.file.name; var b = this.streamFiles &&! a.file.dir; if (b) {var c = m (a, b,! 1, this.currentSourceOffset, this.zipPlatform, this.encodeFileName); this.push ({data: c. fileRecord, meta: {percent: 0}})} más this.accumulate =! 0}, d.prototype.closedSource = function (a) {this.accumulate =! 1; var b = this.streamFiles &&! a.file. dir, c = m (a, b,! 0, this.currentSourceOffset, this.zipPlatform, this.encodeFileName); if (this.dirRecords.push (c.dirRecord), b) this.push ({data: o ( a), meta: {porcentaje:100}}); else for (this.push ({data: c.fileRecord, meta: {percent: 0}}); this.contentBuffer.length;) this.push (this.contentBuffer.shift ()); this .currentFile = null}, d.prototype.flush = function () {for (var a = this.bytesWritten, b = 0; b <this.dirRecords.length; b ++) this.push ({data: this.dirRecords [ b], meta: {percent: 100}}); var c = this.bytesWritten-a, d = n (this.dirRecords.length, c, a, this.zipComment, this.encodeFileName); this.push ({ data: d, meta: {percent: 100}})}, d.prototype.prepareNextSource = function () {this.previous = this._sources.shift (), this.openedSource (this.previous.streamInfo), this. isPaused? this.previous.pause (): this.previous.resume ()}, d.prototype.registerPrevious = function (a) {this._sources.push (a); var b = this; return a.on (" data ", function (a) {b.processChunk (a)}), a.on (" end ", function () {b.closedSource (b.previous.streamInfo), b._sources.length? b.prepareNextSource (): b.end ()}), a.on ("error", function (a) {b.error (a)}), this}, d.prototype.resume = function () {return !! f.prototype.resume.call (this) && (! this.previous && this._sources.length? (this.prepareNextSource () ,! 0): this.previous || this._sources.length || this.generatedError? void 0 : (this.end () ,! 0))}, d.prototype.error = function (a) {var b = this._sources; if (! f.prototype.error.call (this, a)) return! 1; for (var c = 0; c <b.length; c ++) intente {b [c] .error (a)} catch (a) {} return! 0}, d.prototype.lock = function () { f.prototype.lock.call (this); for (var a = this._sources, b = 0; b <a.length; b ++) a [b] .lock ()}, b.exports = d}, { "../crc32":4,"../signature":23,"../stream/GenericWorker":28,"../utf8":31,"../utils":32}font>,9 : [function (a, b, c) {"use estricto"; var d = a ("../ compresiones"), e = a ("./ ZipFileWorker"), f = función (a, b) {var c = a || b, e = d [c]; si (! e) arroja un nuevo error (c + "¡no es un método de compresión válido!"); devuelve e} ; c.generateWorker = function (a, b, c) {var d = new e (b.streamFiles, c, b.platform, b.encodeFileName), g = 0; pruebe {a.forEach (function (a, c ) {g ++; var e = f (c.options.compression, b.compression), h = c.options.compressionOptions || b.compressionOptions || {}, i = c.dir, j = c.date; c ._compressWorker (e, h) .withStreamInfo ("archivo", {nombre: a, dir: i, fecha: j, comentario: c.comment || "", unixPermissions: c.unixPermissions, dosPermissions: c.dosPermissions}) .pipe (d)}), d.entriesCount = g} catch (h) {d.error (h)} return d}}, {"../ compresiones": 3, "./ ZipFileWorker": 8}] , 10: [function (a, b, c) {"use estricto"; función d () {if (! (This instanceof d)) return new d; if (argumentos.length) arroja un nuevo error ("El constructor con los parámetros se han eliminado en JSZip 3.0,consulte la guía de actualización. "); this.files = {}, this.comment = null, this.root =" ", this.clone = function () {var a = new d; for (var b in this) "function"! = typeof this [b] && (a [b] = this [b]); devuelve a}} d.prototype = a ("./ object"), d.prototype.loadAsync = a (". /load"),d.support=a("./support"),d.defaults=a("./defaults"),d.version="3.1.3",d.loadAsync=function(a,b ) {return (nuevo d) .loadAsync (a, b)}, d.external = a ("./ external"), b.exports = d}, {"./ por defecto": 5, "./ external" : 6, "./ load": 11, "./ object": 15, "./ support": 30}], 11: [function (a, b, c) {"use estricto"; función d (a ) {return new f.Promise (function (b, c) {var d = a.decompressed.getContentWorker (). pipe (new i); d.on ("error", function (a) {c (a)} ) .on ("fin", función () {d.streamInfo.crc32! == a.decompressed.crc32? c (nuevo error ("Zip dañado: falta de coincidencia CRC32")): b ()}). resume ()})} var e = a ("./ utils"), f = a ("./ externo"), g = a ("./ utf8"), e = a ("./ utils"), h = a ("./ zipEntries"), i = a ("./ stream / Crc32Probe "), j = a (" ./ nodejsUtils "); b.exports = function (a, b) {var c = this; return b = e.extend (b || {}, {base64 :! 1, checkCRC32:! 1, optimizedBinaryString:! 1, createFolders:! 1, decodeFileName: g.utf8decode}), j.isNode && j.isStream (a)? F.Promise.reject (nuevo error ("JSZip no puede aceptar un flujo al cargar un archivo zip. ")): e.prepareContent (" el archivo zip cargado ", a,! 0, b.optimizedBinaryString, b.base64) .then (function (a) {var c = new h (b ); devuelve c.load (a), c}). then (function (a) {var c = [f.Promise.resolve (a)], e = a.files; if (b.checkCRC32) para (var g = 0; g <longitud e; g ++) c.push (d (e [g]));return f.Promise.all (c)}). then (function (a) {for (var d = a.shift (), e = d.files, f = 0; f <e.length; f ++) {var g = e [f]; c.file (g.fileNameStr, g.decompressed, {binary:! 0, optimizedBinaryString:! 0, date: g.date, dir: g.dir, comment: g.fileCommentStr.length? g.fileCommentStr: null, unixPermissions: g.unixPermissions, dosPermissions: g.dosPermissions, createFolders: b.createFolders})} return d.zipComment.length && (c.comment = d.zipComment), c})}}, {" ./external":6,"./nodejsUtils":14,"./stream/Crc32Probe":25,"./utf8":31,"./utils":32,"./zipEntries":33}] , 12: [function (a, b, c) {"use estricto"; función d (a, b) {f.call (this, "Adaptador de entrada de flujo Nodejs para" + a), this._upstreamEnded =! 1, this._bindStream (b)} var e = a ("../ utils"), f = a ("../ stream / GenericWorker"); e.inherits (d, f), d.prototype._bindStream = function (a) {var b = this; this._stream = a, a.pause (), a.on ("data", function (a) {b.push ({data: a, meta: {percent : 0}})}). On ("error", función (a) {b.isPaused? This.generatedError = a: b.error (a)}). On ("end", function () {b. isPaused? b._upstreamEnded =! 0: b.end ()})}, d.prototype.pause = function () {return !! f.prototype.pause.call (this) && (this._stream.pause () ,! 0)}, d.prototype.resume = function () {return !! f.prototype.resume.call (this) && (this._upstreamEnded? This.end (): this._stream.resume () ,! 0)}, b.exports = d}, {"../ stream / GenericWorker": 28, "../ utils": 32}], 13: [función (a, b, c) {"use estricto" ; función d (a, b, c) {e.call (this, b), this._helper = a; var d = this; a.on ("data", function (a, b) {d.push ( a) || d._helper.pause (), c && c (b)}). on ("error", function (a) {d.emit ("error", a)}). on ("end ", function () {d.push (null)})} var e = a (" readable-stream "). Legible, f = a (" util "); f.inherits (d, e), d. prototype._read = function () {this._helper.resume ()}, b.exports = d}, {"readable-stream": 16, util: void 0}], 14: [function (a, b, c ) {"use estricto"; b.exports = {isNode: "undefined"! = typeof Buffer, newBuffer: function (a, b) {return new Buffer (a, b)}, isBuffer: function (a) {return Buffer .isBuffer (a)}, isStream: function (a) {return a && "function" == typeof a.on && "function" == typeof a.pause && "function" == typeof a.resume}}}, {}] , 15: [function (a, b, c) {"use estricto"; función d (a) {return "[object RegExp]" === Object.prototype.toString.call (a)} var e = a ( "./utf8"),f=a("./utils"),g=a("./stream/GenericWorker"),h=a("./stream/StreamHelper"),i = a ("./ valores predeterminados"), j = a ("./ compressedObject"), k = a ("./ zipObject"), l = a ("./ generate"), m = a (". /nodejsUtils"),n=a("./nodejs/NodejsStreamInputAdapter"),o=function(a,b,c){var d, e = f.getTypeOf (b), h = f.extend (c || {}, i); h.date = h.date || nueva fecha, nulo! == h.compression && (h.compression = h.compression.toUpperCase ()), "string" == typeof h.unixPermissions && (h .unixPermissions = parseInt (h.unixPermissions, 8)), h.unixPermissions && 16384 & h.unixPermissions && (h.dir =! 0), h.dosPermissions && 16 & h.dosPermissions && (h.dir =! 0), h.dir && (a = q (a )), h.createFolders && (d = p (a)) && r.call (this, d,! 0); var l = "string" === e && h.binary ===! 1 && h.base64 ===! 1 ; c && "undefined"! = typeof c.binary || (h.binary =! l);var o = b instancia de j && 0 === b.uncompressedSize; (o || h.dir ||! b || 0 === b.length) && (h.base64 =! 1, h.binary =! 0, b = "", h.compression = "STORE", e = "string"); var s = null; s = b instanceof j || b instanceof g? b: m.isNode && m.isStream (b)? new n ( a, b): f.prepareContent (a, b, h.binary, h.optimizedBinaryString, h.base64); var t = new k (a, s, h); this.files [a] = t}, p = función (a) {"/" === a.slice (-1) && (a = a.substring (0, a.length-1)); var b = a.lastIndexOf ("/"); return b> 0? a.substring (0, b): ""}, q = función (a) {return "/"! == a.slice (-1) && (a + = "/"), a}, r = función (a, b) {return b = "undefined"! = typeof b? b: i.createFolders, a = q (a), this.files [a] || o.call (this, a, null , {dir:! 0, createFolders: b}), this.files [a]}, s = {load: function () {throw new Error ("Este método se ha eliminado en JSZip 3.0,consulte la guía de actualización. ")}, forEach: function (a) {var b, c, d; for (b in this.files) this.files.hasOwnProperty (b) && (d = this.files [b] , c = b.slice (this.root.length, b.length), c && b.slice (0, this.root.length) === this.root && a (c, d))}, filter: function (a) {var b = []; devuelve this.forEach (function (c, d) {a (c, d) && b.push (d)}), b}, file: function (a, b, c) {if ( 1 === argumentos.length) {if (d (a)) {var e = a; devuelve this.filter (function (a, b) {return! B.dir && e.test (a)})} var f = this.files [this.root + a]; return f &&! f.dir? f: null} return a = this.root + a, o.call (this, a, b, c), this}, folder: function (a) {if (! a) devuelve esto; if (d (a)) devuelve this.filter (function (b, c) {return c.dir && a.test (b)}); var b = this.root + a, c = r.call (this, b), e = this.clone (); return e.root = c.name, e}, remove: function (a) {a = this.root + a; var b = this.files [a]; if (b || ("/"! == a.slice (-1) && (a + = "/"), b = this.files [a]), b &&! b.dir) eliminar this.files [a]; else para (var c = this.filter (function ( b, c) {return c.name.slice (0, a.length) === a}), d = 0; d <c.length; d ++) eliminar this.files [c [d] .name]; devolver esto}, generar: función (a) {lanzar un nuevo error ("Este método se ha eliminado en JSZip 3.0, consulte la guía de actualización")}, generateInternalStream: función (a) {var b, c = {}; intente {if (c = f.extend (a || {}, {streamFiles:! 1, compresión: "STORE", compressOptions: null, type: "", platform: "DOS", comment: null, mimeType: " application / zip ", encodeFileName: e.utf8encode}), c.type = c.type.toLowerCase (), c.compression = c.compression.toUpperCase ()," binarystring "=== c.type && (c.type = "string") ,! c.type) arroja un nuevo error ("No se especificó ningún tipo de salida"); f.checkSupport (c.type), "darwin "! == c.platform &&" freebsd "! == c.platform &&" linux "! == c.platform &&" sunos "! == c.platform || (c.platform =" UNIX ")," win32 " === c.platform && (c.platform = "DOS"); var d = c.comment || this.comment || ""; b = l.generateWorker (this, c, d)} catch (i) { b = new g ("error"), b.error (i)} return new h (b, c.type || "string", c.mimeType)}, generateAsync: function (a, b) {return this. generateInternalStream (a) .accumulate (b)}, generateNodeStream: function (a, b) {return a = a || {}, a.type || (a.type = "nodebuffer"), this.generateInternalStream (a) .toNodejsStream (b)}}; b.exports = s}, {"./ compressedObject": 2, "./ por defecto": 5, "./ generate": 9, "./ nodejs / NodejsStreamInputAdapter": 12, "./nodejsUtils":14,"./stream/GenericWorker":28,"./stream/StreamHelper":29,"./utf8":31,"./utils":32,"./zipObject":35}font>.16:[function(a,b,c){b. export = a ("stream")}, {stream: void 0}], 17: [function (a, b, c) {"use estricto"; función d (a) {e.call (this, a); para (var b = 0; b <this.data.length; b ++) a [b] = 255 & a [b]} var e = a ("./ DataReader"), f = a ("../ utils") ; f.inherits (d, e), d.prototype.byteAt = function (a) {return this.data [this.zero + a]}, d.prototype.lastIndexOfSignature = function (a) {for (var b = a.charCodeAt (0), c = a.charCodeAt (1), d = a.charCodeAt (2), e = a.charCodeAt (3), f = this.length-4; f> = 0; - f ) if (this.data [f] === b && this.data [f + 1] === c && this.data [f + 2] === d && this.data [f + 3] === e) devuelve f- this.zero; return-1}, d.prototype.readAndCheckSignature = function (a) {var b = a.charCodeAt (0), c = a.charCodeAt (1), d = a.charCodeAt (2), e = a.charCodeAt (3),f = this.readData (4); devuelve b === f [0] && c === f [1] && d === f [2] && e === f [3]}, d.prototype.readData = función (a) {if (this.checkOffset (a), 0 === a) return []; var b = this.data.slice (this.zero + this.index, this.zero + this.index + a ); devuelva this.index + = a, b}, b.exports = d}, {"../ utils": 32, "./ DataReader": 18}], 18: [función (a, b, c) {"use estricto"; función d (a) {this.data = a, this.length = a.length, this.index = 0, this.zero = 0} var e = a ("../ utils") ; d.prototype = {checkOffset: function (a) {this.checkIndex (this.index + a)}, checkIndex: function (a) {if (this.length <this.zero + a || a <0) throw nuevo error ("Fin de datos alcanzados (longitud de datos =" + this.length + ", índice solicitado =" + a + "). ¿Zip dañado?")}, setIndex: function (a) {this.checkIndex (a), this .index = a}, omitir: función (a) {this.setIndex (this.index + a)}, byteAt: función (a) {},readInt: function (a) {var b, c = 0; for (this.checkOffset (a), b = this.index + a-1; b> = this.index; b -) c = (c << 8) + this.byteAt (b); devuelve this.index + = a, c}, readString: function (a) {return e.transformTo ("string", this.readData (a))}, readData: function (a ) {}, lastIndexOfSignature: function (a) {}, readAndCheckSignature: function (a) {}, readDate: function () {var a = this.readInt (4); return new Date (Date.UTC ((a >> 25 y 127) +1980, (a >> 21 y 15) -1, a >> 16 y 31, a >> 11 y 31, a >> 5 y 63, (31 y a) << 1))}}, b.exports = d}, {". ./utils":32}font>.19:[function(a,b,c){"use estricto "; función d (a) {e.call (this, a)} var e = a (" ./ Uint8ArrayReader "), f = a (" ../ utils "); f.inherits (d, e), d.prototype.readData = function (a) {this.checkOffset (a); var b = this.data.slice (this.zero + this.index, this.zero + this.index + a); devuelva this.index + = a, b}, b.exportaciones = d}, {"../ utils": 32, "./ Uint8ArrayReader": 21}], 20: [función (a, b, c) {"usar estricto"; función d (a) {e. llame a (this, a)} var e = a ("./ DataReader"), f = a ("../ utils"); f.inherits (d, e), d.prototype.byteAt = function (a) {return this.data.charCodeAt (this.zero + a)}, d.prototype.lastIndexOfSignature = function (a) {return this.data.lastIndexOf (a) -this.zero}, d.prototype.readAndCheckSignature = function ( a) {var b = this.readData (4); devuelve a === b}, d.prototype.readData = function (a) {this.checkOffset (a); var b = this.data.slice (this. cero + this.index, this.zero + this.index + a); devuelve this.index + = a, b}, b.exports = d}, {"../ utils": 32, "./ DataReader": 18}], 21: [función (a, b, c) {"usar estricto"; función d (a) {e.call (this, a)} var e = a ("./ ArrayReader"), f = a ("../ utils"); f. hereda (d, e), d. prototipo.readData = function (a) {if (this.checkOffset (a), 0 === a) return new Uint8Array (0); var b = this.data.subarray (this.zero + this.index, this.zero + this.index + a); devuelve this.index + = a, b}, b.exports = d}, {"../ utils": 32, "./ ArrayReader": 17}], 22: [función (a , b, c) {"use estricto"; var d = a ("../ utils"), e = a ("../ support"), f = a ("./ ArrayReader"), g = a ("./StringReader"),h=a("./NodeBufferReader"),i=a("./Uint8ArrayReader");b.exports=function(a){var b = d.getTypeOf (a); return d.checkSupport (b), "string"! == b || e.uint8array? "nodebuffer" === b? new h (a): e.uint8array? new i (d.transformTo ("uint8array", a )): new f (d.transformTo ("array", a)): new g (a)}}, {"../ support": 30, "../ utils": 32, "./ ArrayReader" : 17, "./ NodeBufferReader": 19, "./StringReader":20,"./Uint8ArrayReader":21}font>,23:[function(a,b,c){"use estricto "; c.LOCAL_FILE_HEADER =" PK ?? ", c.CENTRAL_FILE_HEADER =" PK? ? ", c.CENTRAL_DIRECTORY_END =" PK ?? ", c.ZIP64_CENTRAL_DIRECTORY_LOCATOR =" PK ?? ", c.ZIP64_CENTRAL_DIRECTORY_END =" PK ?? ", c.DATA_DESCRIPTOR =" PK? \ b "}, {}], 24 : [function (a, b, c) {"use estricto"; función d (a) {e.call (this, "ConvertWorker to" + a), this.destType = a} var e = a ("./ GenericWorker "), f = a (" ../ utils "); f.inherits (d, e), d.prototype.processChunk = function (a) {this.push ({data: f.transformTo (this.destType , a.data), meta: a.meta})}, b.exports = d}, {"../ utils": 32, "./ GenericWorker": 28}], 25: [función (a, b , c) {"use estricto"; función d () {e.call (this, "Crc32Probe"), this.withStreamInfo ("crc32",0)} var e = a ("./ GenericWorker"), f = a ("../ crc32"), g = a ("../ utils"); g. hereda (d, e), d. prototype.processChunk = function (a) {this.streamInfo.crc32 = f (a.data, this.streamInfo.crc32 || 0), this.push (a)}, b.exports = d}, {".. /crc32":4,"../utils":32,"./GenericWorker":28}font>,26:[function(a,b,c){"use estricto "; función d (a) {f. llamada (this, "DataLengthProbe for" + a), this.propName = a, this.withStreamInfo (a, 0)} var e = a ("../ utils"), f = a ("./ GenericWorker") ; e.inherits (d, f), d.prototype.processChunk = function (a) {if (a) {var b = this.streamInfo [this.propName] || 0; this.streamInfo [this.propName] = b + a.data.length} f.prototype.processChunk.call (this, a)}, b.exports = d}, {"../ utils": 32, "./ GenericWorker": 28}], 27 : [función (a, b, c) {"usar estricto"; función d (a) {f.call (esto, "DataWorker "); var b = this; this.dataIsReady =! 1, this.index = 0, this.max = 0, this.data = null, this.type =" ", this._tickScheduled =! 1, a. entonces (función (a) {b.dataIsReady =! 0, b.data = a, b.max = a && a.length || 0, b.type = e.getTypeOf (a), b.isPaused || b._tickAndRepeat ()}, función (a) {b.error (a)})} var e = a ("../ utils"), f = a ("./ GenericWorker"), g = 16384; e.inherits ( d, f), d.prototype.cleanUp = function () {f.prototype.cleanUp.call (this), this.data = null}, d.prototype.resume = function () {return !! f.prototype. resume.call (this) && (! this._tickScheduled && this.dataIsReady && (this._tickScheduled =! 0, e.delay (this._tickAndRepeat, [], this)) ,! 0)}, d.prototype._tickAndRepeat = function ( ) {this._tickScheduled =! 1, this.isPaused || this.isFinished || (this._tick (), this.isFinished || (e.delay (this._tickAndRepeat, [], this), this._tickScheduled = ! 0))}, d.prototipo._tick = function () {if (this.isPaused || this.isFinished) return! 1; var a = g, b = null, c = Math.min (this.max, this.index + a); if (this .index> = this.max) return this.end (); switch (this.type) {case "string": b = this.data.substring (this.index, c); break; case "uint8array": b = this.data.subarray (this.index, c); break; case "array": case "nodebuffer": b = this.data.slice (this.index, c)} devuelve this.index = c, this. push ({data: b, meta: {percent: this.max? this.index / this.max * 100: 0}})}, b.exports = d}, {"../ utils": 32, " ./GenericWorker":28}font>,28:[function(a,b,c){"use estricto "; función d (a) {this.name = a ||" default ", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused =! 0, this.isFinished =! 1, this.isLocked =! 1, this._listeners = {data: [], end: [], error : []}, this.previous = null} d.prototype = {push: function (a) {this.emit ("data", a)}, end: function () {if (this.isFinished) return! 1; this.flush (); try {this.emit ("end"), this.cleanUp (), this .isFinished =! 0} catch (a) {this.emit ("error", a)} return! 0}, error: function (a) {return! this.isFinished && (this.isPaused? this.generatedError = a: (this.isFinished =! 0, this.emit ("error", a), this.previous && this.previous.error (a), this.cleanUp ()) ,! 0)}, on: function (a, b) {devuelve this._listeners [a] .push (b), this}, cleanUp: function () {this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = []}, emit: function (a , b) {if (this._listeners [a]) for (var c = 0; c <this._listeners [a] .length; c ++) this._listeners [a] [c] .call (this, b)} , pipe: function (a) {return a.registerPrevious (this)}, registerPrevious: function (a) {if (this.isLocked) throw new Error ("The stream '" + this + "'ya se ha utilizado. "); this.streamInfo = a.streamInfo, this.mergeStreamInfo (), this.previous = a; var b = this; return a.on (" data ", function (a) {b.processChunk (a)}), a.on ("fin", función () {b.end ()}), a.on ("error", función (a) {b.error (a)}), esto} , pausa: function () {return! this.isPaused &&! this.isFinished && (this.isPaused =! 0, this.previous && this.previous.pause () ,! 0)}, resume: function () {if (! this. isPaused || this.isFinished) return! 1; this.isPaused =! 1; var a =! 1; return this.generatedError && (this.error (this.generatedError), a =! 0), this.previous && this.previous. resume () ,! a}, flush: function () {}, processChunk: function (a) {this.push (a)}, withStreamInfo: function (a, b) {return this.extraStreamInfo [a] = b, this.mergeStreamInfo (), this}, mergeStreamInfo: function () {for (var a in this.extraStreamInfo) this.extraStreamInfo.hasOwnProperty (a) && (this.streamInfo [a] = this.extraStreamInfo [a])}, lock: function () {if (this.isLocked) arroja un nuevo error ("The stream '" + this + "' ya ha sido utilizado. "); this.isLocked =! 0, this.previous && this.previous.lock ()}, toString: function () {var a =" Worker "+ this.name; return this.previous? this.previous +" - > "+ a: a}}, b.exports = d}, {}], 29: [función (a, b, c) {" usar estricto "; función d (a, b, c, d) {var f = nulo; switch (a) {case "blob": return h.newBlob (c, d); case "base64": return f = e (b, c), k.encode (f); predeterminado: return f = e (b, c), h.transformTo (a, f)}} función e (a, b) {var c, d = 0, e = nulo, f = 0; para (c = 0; c <b .length; c ++) f + = b [c] .length; switch (a) {case "string": return b.join (""); case "array": return Array.prototype.concat.apply ([], b); caso "uint8array":for (e = new Uint8Array (f), c = 0; c <b.length; c ++) e.set (b [c], d), d + = b [c] .length; return e; case "nodebuffer" : return Buffer.concat (b); valor predeterminado: arrojar un nuevo error ("concat: tipo no admitido '" + a + "'")}} función f (a, b) {return new m.Promise (function (c, e) {var f = [], g = a._internalType, h = a._outputType, i = a._mimeType; a.on ("data", function (a, c) {f.push (a), b && b (c )}). on ("error", función (a) {f = [], e (a)}). on ("fin", función () {try {var a = d (h, g, f, i); c (a)} catch (b) {e (b)} f = []}). resume ()})} función g (a, b, c) {var d = b; interruptor (b) {case "blob": d = "arraybuffer"; break; case "arraybuffer": d = "uint8array"; break; case "base64": d = "string"} try {this._internalType = d, this._outputType = b, this._mimeType = c, h.checkSupport (d), this._worker = a.pipe (nuevo i (d)), a.lock ()} catch (e) {this._worker = new j ("error"), this._worker.error (e)}} var h = a ("../ utils"), i = a ("./ ConvertWorker"), j = a (". /GenericWorker"),k=a("../base64"),l=a("../support"),m=a("../external"),n=null;if(l.nodestream ) intente {n = a ("../ nodejs / NodejsStreamOutputAdapter")} catch (o) {} g.prototype = {acumular: función (a) {return f (this, a)}, on: function (a, b) {var c = this; return "data" === a? this._worker.on (a, function (a) {b.call (c, a.data, a.meta)}): this._worker .on (a, function () {h.delay (b, argumentos, c)}), this}, resume: function () {return h.delay (this._worker.resume, [], this._worker), this}, pausa: function () {return this._worker.pause (), this}, toNodejsStream: function (a) {if (h.checkSupport ("nodestream"), "nodebuffer"! == this._outputType) throw nuevo error (this._outputType + "no es compatible con este método "); devuelve nuevo n (this, {objectMode:" nodebuffer "! == this._outputType}, a)}}, b.exports = g}, {" ../ base64 ": 1 , "../ external": 6, "../ nodejs / NodejsStreamOutputAdapter": 13, "../ support": 30, "../ utils": 32, "./ ConvertWorker": 24, "./ GenericWorker ": 28}], 30: [function (a, b, c) {" use estricto "; if (c.base64 =! 0, c.array =! 0, c.string =! 0, c.arraybuffer = "undefined"! = typeof ArrayBuffer && "undefined"! = typeof Uint8Array, c.nodebuffer = "undefined"! = typeof Buffer, c.uint8array = "undefined"! = typeof Uint8Array, "undefined" == typeof ArrayBuffer) c. blob =! 1; else {var d = new ArrayBuffer (0); pruebe {c.blob = 0 === new Blob ([d], {type: "application / zip"}). size} catch (e) {try {var f = window.BlobBuilder || ventana.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder, g = new f; g.append (d), c.blob = 0 === g.getBlob ("application / zip"). Size} catch (e) { c.blob =! 1}}} intente {c.nodestream = !! a ("readable-stream"). Legible} catch (e) {c.nodestream =! 1}}, {"readable-stream": 16 }], 31: [function (a, b, c) {"use estricto"; función d () {i.call (this, "utf-8 decode"), this.leftOver = null} function e () { i.call (esto, "codificación utf-8")} para (var f = a ("./ utils"), g = a ("./ support"), h = a ("./ nodejsUtils"), i = a ("./ stream / GenericWorker"), j = nueva matriz (256), k = 0; k <256; k ++) j [k] = k> = 252? 6: k> = 248? 5: k> = 240? 4: k> = 224? 3: k> = 192? 2: 1; j [254] = j [254] = 1; var l = función (a) {var b, c, d, e, f, h = a.length, i = 0; for (e = 0; e <h; e ++) c = a.charCodeAt (e), 55296 === (64512 & c) && e + 1 <h && (d = a.charCodeAt (e + 1),56320 === (64512 & d) && (c = 65536 + (c-55296 << 10) + (d-56320), e ++)), i + = c <128? 1: c <2048? 2: c <65536? 3: 4; para (b = g.uint8array? New Uint8Array (i): new Array (i), f = 0, e = 0; f <i; e ++) c = a.charCodeAt (e), 55296 == = (64512 & c) && e + 1 <h && (d = a.charCodeAt (e + 1), 56320 === (64512 & d) && (c = 65536 + (c-55296 << 10) + (d-56320), e ++ )), c <128? b [f ++] = c: c <2048? (b [f ++] = 192 | c >>> 6, b [f ++] = 128 | 63 & c): c <65536? (b [f ++ ] = 224 | c >>> 12, b [f ++] = 128 | c >>> 6 y 63, b [f ++] = 128 | 63 y c) :( b [f ++] = 240 | c >>> 18, b [f ++ ] = 128 | c >>> 12 y 63, b [f ++] = 128 | c >>> 6 y 63, b [f ++] = 128 | 63 & c); devuelve b}, m = función (a, b) {var c; para (b = b || a.length, b> a.length && (b = a.length), c = b-1; c> = 0 && 128 === (192 & a [c]);) c -; return c <0? B: 0 === c? B: c + j [a [c]]> b? C: b}, n = función (a) {var b, c, d, e, g = a. longitud,h = nueva matriz (2 * g); para (c = 0, b = 0; b <g;) if (d = a [b ++], d <128) h [c ++] = d; si if (e = j [d], e> 4) h [c ++] = 65533, b + = e-1; más {para (d & = 2 === e? 31: 3 === e? 15: 7; e> 1 && b < g;) d = d << 6 | 63 & a [b ++], e -; e> 1? h [c ++] = 65533: d <65536? h [c ++] = d: (d- = 65536, h [c ++ ] = 55296 | d >> 10 y 1023, h [c ++] = 56320 | 1023 yd)} return h.length! == c && (h.subarray? H = h.subarray (0, c): h.length = c), f.applyFromCharCode (h)}; c.utf8encode = function (a) {return g.nodebuffer? h.newBuffer (a, "utf-8"): l (a)}, c.utf8decode = function (a) { return g.nodebuffer? f.transformTo ("nodebuffer", a) .toString ("utf-8") :( a = f.transformTo (g.uint8array? "uint8array": "array", a), n (a ))}, f.inherits (d, i), d.prototype.processChunk = function (a) {var b = f.transformTo (g.uint8array? "uint8array": "array", a.data); if ( this.leftOver && this.leftOver.longitud) {if (g.uint8array) {var d = b; b = new Uint8Array (d.length + this.leftOver.length), b.set (this.leftOver, 0), b.set (d, this. leftOver.length)} else b = this.leftOver.concat (b); this.leftOver = null} var e = m (b), h = b; e! == b.length && (g.uint8array? (h = b.subarray (0, e), this.leftOver = b.subarray (e, b.length)) :( h = b.slice (0, e), this.leftOver = b.slice (e, b.length ))), this.push ({data: c.utf8decode (h), meta: a.meta})}, d.prototype.flush = function () {this.leftOver && this.leftOver.length && (this.push ({ datos: c.utf8decode (this.leftOver), meta: {}}), this.leftOver = null)}, c.Utf8DecodeWorker = d, f.inherits (e, i), e.prototype.processChunk = function (a ) {this.push ({datos: c.utf8encode (a.data), meta: a.meta})}, c.Utf8EncodeWorker = e}, {"./ nodejsUtils": 14, "./ stream / GenericWorker" : 28, "./ support": 30, "./ utils": 32}], 32: [función (a, b, c) {"use estricto";función d (a) {var b = null; return b = i.uint8array? new Uint8Array (a.length): new Array (a.length), f (a, b)} function e (a) {return a} función f (a, b) {para (var c = 0; c <a.length; ++ c) b [c] = 255 & a.charCodeAt (c); return b} función g (a) {var b = 65536 , d = c.getTypeOf (a), e =! 0; if ("uint8array" === d? e = n.applyCanBeUsed.uint8array: "nodebuffer" === d && (e = n.applyCanBeUsed.nodebuffer), e) para (; b> 1;) intente {return n.stringifyByChunk (a, d, b)} catch (f) {b = Math.floor (b / 2)} return n.stringifyByChar (a)} función h (a, b) {para (var c = 0; c <a.length; c ++) b [c] = a [c]; return b} var i = a ("./ support"), j = a ( "./base64"),k=a("./nodejsUtils"),l=a("core-js/library/fn/set-immediate"),m=a("./external");c. newBlob = function (a, b) {c.checkSupport ("blob"); try {return new Blob (a, {type: b})} catch (d) {try {for (var e = window.BlobBuilder || ventana.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder, f = new e, g = 0; g <a.length; g ++) f.append (a [g]);
    return f.getBlob (b)} catch (d) {throw new Error ("Error: no se puede construir el Blob.")}}}; var n = {stringifyByChunk: function (a, b, c) {var d = [], e = 0, f = a.length; if (f <= c) devuelve String.fromCharCode.apply (null, a); for (; e <f;) "array" === b || "nodebuffer" === b? d.push (String.fromCharCode.apply (null, a.slice (e, Math.min (e + c, f)))): d.push (String.fromCharCode.apply ( nulo, a.subarray (e, Math.min (e + c, f)))), e + = c; return d.join ("")}, stringifyByChar: function (a) {for (var b = "" , c = 0; c <a.length; c ++) b + = String.fromCharCode (a [c]); return b}, applyCanBeUsed: {uint8array: function () {try {return i.uint8array && 1 === String.fromCharCode .apply (nulo, nuevo Uint8Array (1)). length} catch (a) {return! 1}} (), nodebuffer: function () {try {return i.nodebuffer && 1 === String.fromCharCode.apply (null, k.newBuffer (1)). length} catch (a) {return! 1}} ()}}; c.applyFromCharCode = g; var o = {}; o.string = {string: e, array: function (a) {return f (a, new Array (a.length))}, arraybuffer: function (a) {return o .string.uint8array (a) .buffer}, uint8array: function (a) {return f (a, new Uint8Array (a.length))}, nodebuffer: function (a) {return f (a, k.newBuffer (a .length))}}, o.array = {string: g, array: e, arraybuffer: function (a) {return new Uint8Array (a) .buffer}, uint8array: function (a) {return new Uint8Array (a) }, nodebuffer: function (a) {return k.newBuffer (a)}}, o.arraybuffer = {string: function (a) {return g (new Uint8Array (a))}, array: function (a) {return h (nueva Uint8Array (a), nueva matriz (a.byteLength))}, arraybuffer: e, uint8array: function (a) {return new Uint8Array (a)}, nodebuffer: function (a) {return k.newBuffer (new Uint8Array (a))}}, o.uint8array = {string: g, array: function (a) {return h (a, new Array (a.length))}, arraybuffer: function (a) {var b = new Uint8Array (a.length); devuelve a.longitud && b.set (a, 0), b.buffer}, uint8array: e, nodebuffer: function (a) {return k.newBuffer (a)}}, o.nodebuffer = {string: g, array: function (a) {return h (a, new Array (a.length))}, arraybuffer: function (a) {return o.nodebuffer.uint8array (a) .buffer}, uint8array: function (a) {return h (a, new Uint8Array (a.length))}, nodebuffer: e}, c.transformTo = function (a, b) {if (b || (b = "") ,! a) return b; c.checkSupport (a); var d = c.getTypeOf (b), e = o [d] [a] (b); return e}, c.getTypeOf = function (a) {return "string" == typeof a? "string": "[ object Array] "=== Object.prototype.toString.call (a)?" array ": i.nodebuffer && k.isBuffer (a)?" nodebuffer ": i.uint8array && una instancia de Uint8Array?" uint8array ": i.arraybuffer && una instancia de ArrayBuffer ? "arraybuffer": void 0}, c.checkSupport = function (a) {var b = i [a.toLowerCase ()]; if (!b) arrojar un nuevo error (a + "no es compatible con esta plataforma")}, c.MAX_VALUE_16BITS = 65535, c.MAX_VALUE_32BITS = -1, c.pretty = function (a) {var b, c, d = ""; para (c = 0; c <(a || ""). length; c ++) b = a.charCodeAt (c), d + = "\\ x" + (b <16? "0": "") + b.toString (16) .toUpperCase (); return d}, c.delay = function (a, b, c) {l (function () {a.apply (c || null, b || [])} )}, c.inherits = function (a, b) {var c = function () {}; c.prototype = b.prototype, a.prototype = new c}, c.extend = function () {var a, b, c = {}; para (a = 0; a <argumentos.length; a ++) para (b en argumentos [a]) argumentos [a] .hasOwnProperty (b) && "undefined" == typeof c [b] && (c [b] = argumentos [a] [b]); devuelve c}, c.prepareContent = function (a, b, e, f, g) {var h = m.Promise.resolve (b) .then (función (a) {var b = i.blob && (una instancia de Blob || ["[archivo de objeto]", "[objeto Blob]"].indexOf (Object.prototype.toString.call (a))! == - 1); devuelve b && "undefined"! = typeof FileReader? new m.Promise (function (b, c) {var d = new FileReader; d. onload = function (a) {b (a.target.result)}, d.onerror = function (a) {c (a.target.error)}, d.readAsArrayBuffer (a)}): a}); return h.then (function (b) {var h = c.getTypeOf (b); return h? ("arraybuffer" === h? b = c.transformTo ("uint8array", b): "string" === h && (g? b = j.decode (b): e && f! ==! 0 && (b = d (b))), b): m.Promise.reject (nuevo error ("Los datos de '" + a + " 'está en un formato no compatible! "))})}}, {" ./ base64 ": 1," ./ external ": 6," ./ nodejsUtils ": 14," ./ support ": 30," core -js / library / fn / set-inmediata ": 36}], 33: [función (a, b, c) {" usar estricto "; función d (a) {this.files = [], this.loadOptions = a} var e = a ("./reader/readerFor"),f=a("./utils"),g=a("./signature"),h=a("./zipEntry"),i=(a("./utf8 " ), a ("./ support")); d.prototype = {checkSignature: function (a) {if (! this.reader.readAndCheckSignature (a)) {this.reader.index- = 4; var b = this .reader.readString (4); arrojar un nuevo error ("Zip o error dañado: firma inesperada (" + f.pretty (b) + ", esperado" + f.pretty (a) + ")")}}, isSignature : función (a, b) {var c = this.reader.index; this.reader.setIndex (a); var d = this.reader.readString (4), e = d === b; devuelve this.reader .setIndex (c), e}, readBlockEndOfCentral: function () {this.diskNumber = this.reader.readInt (2), this.diskWithCentralDirStart = this.reader.readInt (2), this.centralDirRecordsOnThisDisk = this.reader.readInt (2), this.centralDirRecords = this.reader.readInt (2), this.centralDirSize = this.reader.readInt (4), esto.centralDirOffset = this.reader.readInt (4), this.zipCommentLength = this.reader.readInt (2); var a = this.reader.readData (this.zipCommentLength), b = i.uint8array? "uint8array": "matriz ", c = f.transformTo (b, a); this.zipComment = this.loadOptions.decodeFileName (c)}, readBlockZip64EndOfCentral: function () {this.zip64EndOfCentralSize = this.reader.readInt (8), this.reader. skip (4), this.diskNumber = this.reader.readInt (4), this.diskWithCentralDirStart = this.reader.readInt (4), this.centralDirRecordsOnThisDisk = this.reader.readInt (8), this.centralDirRecords = this. reader.readInt (8), this.centralDirSize = this.reader.readInt (8), this.centralDirOffset = this.reader.readInt (8), this.zip64ExtensibleData = {}; para (var a, b, c, d = this.zip64EndOfCentralSize-44, e = 0; e <d;) a = this.reader.readInt (2), b = this.reader.readInt (4), c = this.reader.readData (b), esto .zip64ExtensibleData [a] = {id: a, longitud: b,valor: c}}, readBlockZip64EndOfCentralLocator: function () {if (this.diskWithZip64CentralDirStart = this.reader.readInt (4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt (8), this.disksntoder. 4), this.disksCount> 1) arroja un nuevo error ("Zip de varios volúmenes no son compatibles")}, readLocalFiles: function () {var a, b; for (a = 0; a <this.files.length; a ++) b = this.files [a], this.reader.setIndex (b.localHeaderOffset), this.checkSignature (g.LOCAL_FILE_HEADER), b.readLocalPart (this.reader), b.handleUTF8 (), b.processAttributes ( )}, readCentralDir: function () {var a; for (this.reader.setIndex (this.centralDirOffset); this.reader.readAndCheckSignature (g.CENTRAL_FILE_HEADER);) a = new h ({zip64: this.zip64}, this.loadOptions), a.readCentralPart (this.reader), this.files.push (a); if (this.centralDirRecords! == this.files.length && 0! == this.centralDirRecords && 0 === this.files.length) arroja un nuevo error ("Zip o error dañado: esperado" + this.centralDirRecords + "registros en el directorio central, consiguió" + this.files.length)}, readEndOfCentral: function () {var a = this.reader.lastIndexOfSignature (g.CENTRAL_DIRECTORY_END); if (a <0) {var b =! this.isSignature (0, g.LOCAL_FILE_HEADER); throw b? new Error ("No se puede encontrar el final del directorio central : ¿es esto un archivo zip? Si es así, consulte http://stuk.github.io/jszip/documentation/howto/read_zip.html"):new Error ("Zip dañado: no puede encontrar el final del directorio central" )} this.reader.setIndex (a); var c = a; if (this.checkSignature (g.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral (), this.diskNumber === f.MAX_VALUE_16BITS || this.diskWithCentralDirStart === f.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === f.MAX_VALUE_16BITS || this.centralDirRecords === f.MAX_VALUE_16BITS || this.centralDirSize === f.MAX_VALUE_32BITS || this.centralDirOffset === f.MAX_VALUE_32BITS) {if (this.zip64 =! 0, a = this.reader.lastIndexOfSignature (g.ZIP64_CENT_CENT_CENT_CENT_CENT_CENT_C, < ) lanzar un nuevo error ("Zip dañado: no se puede encontrar el extremo ZIP64 del localizador de directorio central"); if (this.reader.setIndex (a), this.checkSignature (g.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator () ,! .Ig. fin del directorio central "); this.reader.setIndex (this.relativeOffsetEndOfZip64CentralDir), this.checkSignature (g.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral ()} var d = this.centralDirOffset + this.centralDirSize; this.zip64 && (d + = 20, d + = 12 + this.zip64EndOfCentralSize); var e = cd; if (this). isSignature (c, g.CENTRAL_FILE_HEADER) || (this.reader.zero = e); de lo contrario, si (e <0) arroja un nuevo error ("Zip dañado: falta" + Math.abs (e) + "bytes"). }, prepareReader: function (a) {this.reader = e (a)}, load: function (a) {this.prepareReader (a), this.readEndOfCentral (), this.readCentralDir (), this.readLocalFiles () }}, b.exports = d}, {"./ reader / readerFor": 22, "./ signature": 23, "./ support": 30, "./ utf8": 31, "./ utils" : 32, "./ zipEntry": 34}], 34: [función (a, b, c) {"usar estricto"; función d (a, b) {this.options = a, this.loadOptions = b} var e = a ("./ reader / readerFor"), f = a ("./ utils"), g = a ("./compressedObject"),h=a("./crc32"),i=a("./utf8"),j=a("./compressions"),k=a("./support"),l = 0, m = 3, n = función (a) {para (var b en j) if (j.hasOwnProperty (b) && j [b] .magic === a) return j [b]; return null}; d.prototype = {isEncrypted: function () {return 1 === (1 & this.bitFlag)}, useUTF8: function () {return 2048 === (2048 & this.bitFlag)}, readLocalPart: function (a) {var b , c; if (a.skip (22), this.fileNameLength = a.readInt (2), c = a.readInt (2), this.fileName = a.readData (this.fileNameLength), a.skip (c ), this.compressedSize === - 1 || this.uncompressedSize === - 1) arroja un nuevo error ("Error o zip dañado: no obtuvo suficiente información del directorio central (compressedSize === -1 || uncompressedSize === -1) "); if (b = n (this.compressionMethod), null === b) arroja un nuevo error (" Zip dañado: compresión "+ f.pretty (this.compressMethod) + "unknown (archivo interno:" + f.transformTo ("string", this.fileName) + ")"); this.decompressed = new g (this.compressedSize, this.uncompressedSize, this.crc32, b, a.readData (this.compressedSize))}, readCentralPart: function (a) {this.versionMadeBy = a.readInt (2), a.skip (2), this.bitFlag = a.readInt (2), this.compressionMethod = a.readString (2), this.date = a.readDate (), this.crc32 = a.readInt (4), this.compressedSize = a.readInt (4), this.uncompressedSize = a.readInt (4) ; var b = a.readInt (2); if (this.extraFieldsLength = a.readInt (2), this.fileCommentLength = a.readInt (2), this.diskNumberStart = a.readInt (2), this.internalFileAttributes = a.readInt (2), this.externalFileAttributes = a.readInt (4), this.localHeaderOffset = a.readInt (4), this.isEncrypted ()) arroja un nuevo error ("Zip cifrado no son compatibles"); a. omita (b), this.readExtraFields (a), this.parseZIP64ExtraField (a), this.fileComment = a.readData (this.fileCommentLength)}, processAttributes: function () {this.unixPermissions = null, this.dosPermissions = null; var a = this.versionMadeBy >> 8; this.dir = !! (16 & this.externalFileAttributes), a === l && (this.dosPermissions = 63 & this.externalFileAttributes), a === m && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || "/" ! == this.fileNameStr.slice (-1) || (this.dir =! 0)}, parseZIP64ExtraField: function (a) {if (this.extraFields [1]) {var b = e (this.extraFields [ 1] .value); this.uncompressedSize === f.MAX_VALUE_32BITS && (this.uncompressedSize = b.readInt (8)), this.compressedSize === f.MAX_VALUE_32BITS && (this.compressedSize = b.readInt (8)), this.localHeaderOffset === f.MAX_VALUE_32BITS && (this.localHeaderOffset = b.readInt (8)), this.diskNumberStart === f.MAX_VALUE_32BITS && (this.diskNumberStart = b.readInt (4))}}, readExtraFields: function (a) {var b, c, d, e = a.index + this.extraFieldsLength; for (this.extraFields || (this. extraFields = {}); a.index <e;) b = a.readInt (2), c = a.readInt (2), d = a.readData (c), this.extraFields [b] = {id: b, longitud: c, valor: d}}, handleUTF8: function () {var a = k.uint8array? "uint8array": "array"; if (this.useUTF8 ()) this.fileNameStr = i.utf8decode (this .fileName), this.fileCommentStr = i.utf8decode (this.fileComment); else {var b = this.findExtraFieldUnicodePath (); if (null! == b) this.fileNameStr = b; else {var c = f.transformTo (a, this.fileName); this.fileNameStr = this.loadOptions.decodeFileName (c)} var d = this.findExtraFieldUnicodeComment (); if (null! == d) this.fileCommentStr = d; else {var e = f .transformTo (a, this.fileComment); this.fileCommentStr = this.loadOptions.decodeFileName (e)}}}, findExtraFieldUnicodePath:function () {var a = this.extraFields [28789]; if (a) {var b = e (a.value); return 1! == b.readInt (1)? null: h (this.fileName)! == b.readInt (4)? null: i.utf8decode (b.readData (a.length-5))} return null}, findExtraFieldUnicodeComment: function () {var a = this.extraFields [25461]; if (a ) {var b = e (a.value); return 1! == b.readInt (1)? null: h (this.fileComment)! == b.readInt (4)? null: i.utf8decode (b. readData (a.length-5))} return null}}, b.exports = d}, {"./ compressedObject": 2, "./ compressions": 3, "./ crc32": 4, "./ reader / readerFor ": 22," ./ support ": 30," ./ utf8 ": 31," ./ utils ": 32}], 35: [función (a, b, c) {" use estricto "; var d = a ("./ stream / StreamHelper"), e = a ("./ stream / DataWorker"), f = a ("./ utf8"), g = a ("./ compressedObject"), h = a ("./ stream / GenericWorker"), i = function (a, b, c) {this.name = a, this.dir = c.dir, this.date = c.date, this.comment = c.comment, this.unixPermissions = c.unixPermissions, this.dosPermissions = c.dosPermissions, this._data = b, this._dataBinary = c. binario, this.options = {compresión: c.compression, compressOptions: c.compressionOptions}}; i.prototype = {internalStream: function (a) {var b = a.toLowerCase (), c = "string" === b || "text" === b; "binarystring"! == b && "text"! == b || (b = "string"); var e = this._decompressWorker (), g =! this._dataBinary ; devuelve g &&! c && (e = e.pipe (nuevo f.Utf8EncodeWorker)) ,! g && c && (e = e.pipe (nuevo f.Utf8DecodeWorker)), nuevo d (e, b, "")}, async: function (a, b) {return this.internalStream (a) .accumulate (b)}, nodeStream: function (a, b) {return this.internalStream (a || "nodebuffer"). toNodejsStream (b)}, _ compressWorker: función (a, b) {if (esto._data instanceof g && this._data.compression.magic === a.magic) devuelve this._data.getCompressedWorker (); var c = this._decompressWorker (); devuelve this._dataBinary || (c = c.pipe (nueva f. Utf8EncodeWorker)), g.createWorkerFrom (c, a, b)}, _ decompressWorker: function () {return this._data instanceof g? This._data.getContentWorker (): this._data instanceof h? This._data: new e ( this._data)}}; for (var j = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], k = function () {lanzar un nuevo error ("Este método se ha eliminado en JSZip 3.0, consulte la guía de actualización. ")}, l = 0; l <j.length; l ++) i.prototype [j [l]] = k; b.exports = i}, {" ./ compressedObject ": 2," ./ stream / DataWorker ": 27," ./ stream / GenericWorker ": 28," ./ stream / StreamHelper ": 29," ./ utf8 ": 31}], 36: [función (a ,si,c) {a ("../ modules / web.immediate"), b.exports = a ("../ modules / _core"). setImmediate}, {"../ modules / _core": 40, ". ./modules/web.immediate":56}font>,37:[function(a,b,c){b.exports=function(a){if("function"!=typeof a) throw TypeError (a + "es ¡no es una función! "); devuelve a}}, {}], 38: [función (a, b, c) {var d = a (" ./_ es-objeto "); b.exports = función (a) {if (! d (a)) throw TypeError (a + "no es un objeto!"); devuelve a}}, {"./_ es-objeto": 51}], 39: [función (a, b, c ) {var d = {}. toString; b.exports = function (a) {return d.call (a) .slice (8, -1)}}, {}], 40: [function (a, b, c) {var d = b.exports = {versión: "2.3.0"}; "número" == typeof __e && (__ e = d)}, {}], 41: [función (a, b, c) { var d = a ("./_ a-function"); b.exports = function (a, b, c) {if (d (a), void 0 === b) devuelve a; switch (c) {case 1: función de retorno (c) {return a.call (b, c)}; caso 2: función de retorno (c, d) {return a.call (b, c, d)}; caso 3: función de retorno (c, d, e) {return a.call ( b, c, d, e)}} return function () {return a.apply (b, argumentos)}}}, {"./_ a-function": 37}], 42: [function (a, b, c) {b.exports =! a ("./_ falla") (function () {return 7! = Object.defineProperty ({}, "a", {get: function () {return 7}}). a })}, {"./_ falla": 45}], 43: [función (a, b, c) {var d = a ("./_ es-objeto"), e = a ("./_ global" ) .document, f = d (e) && d (e.createElement); b.exports = function (a) {return f? e.createElement (a): {}}}, {"./_ global": 46, "./_is-object":51}},44:[function(a,b,c){var d = a (" ./_ global "), e = a (" ./_ core "), f = a ("./_ctx"),g=a("./_hide"),h="prototype",i=function(a,b,c){var j, k, l, m = a & i.F, n = a & i.G, o = a & i.S, p = a & i.P, q = a & i.B, r = a & i.W,s = n? e: e [b] || (e [b] = {}), t = s [h], u = n? d: o? d [b] :( d [b] || { }) [h]; n && (c = b); para (j en c) k =! m && u && void 0! == u [j], k && j en s || (l = k? u [j]: c [j ], s [j] = n && "function"! = typeof u [j]? c [j]: q && k? f (l, d): r && u [j] == l? function (a) {var b = function (b, c, d) {if (esta instancia de a) {switch (argumentos.length) {caso 0: devolver nuevo a; caso 1: devolver nuevo a (b); caso 2: devolver nuevo a (b, c) } return new a (b, c, d)} return a.apply (esto, argumentos)}; return b [h] = a [h], b} (l): p && "function" == typeof l? f (Function.call, l): l, p && ((s.virtual || (s.virtual = {})) [j] = l, a & i.R && t &&! T [j] && g (t, j, l)) )}; iF = 1, iG = 2, iS = 4, iP = 8, iB = 16, iW = 32, iU = 64, iR = 128, b.exports = i}, {"./_ core": 40 , "./_ ctx": 41, "./_ global": 46, "./_ hide": 47}], 45: [function (a, b, c) {b.exports = function (a) {try { ¡¡regreso!!a ()} catch (b) {return! 0}}}, {}], 46: [function (a, b, c) {var d = b.exports = "undefined"! = typeof window && window.Math == Math? Window: "undefined"! = Typeof self && self.Math == Math? Self: Function ("return this") (); "number" == typeof __g && (__ g = d)}, {}], 47: [ función (a, b, c) {var d = a ("./_ object-dp"), e = a ("./_ property-desc"); b.exports = a ("./_ descriptors")? function (a, b, c) {return df (a, b, e (1, c))}: función (a, b, c) {return a [b] = c, a}}, {"./_ descriptores ": 42," ./_ object-dp ": 52," ./_ property-desc ": 53}], 48: [función (a, b, c) {b.exports = a (" ./_ global ") .document && document.documentElement}, {"./_ global": 46}], 49: [function (a, b, c) {b.exports =! a ("./_ descriptors") &&! a ("./_ falla ") (function () {return 7! = Object.defineProperty (a ("./ _dom-create ") (" div ")," a ", {get: function () {return 7}}). a})}, {" ./_ descriptors ": 42," ./_ dom-create " : 43, "./_ falla": 45}], 50: [función (a, b, c) {b.exports = función (a, b, c) {var d = vacío 0 === c; interruptor ( b.length) {case 0: return d? a (): a.call (c); case 1: return d? a (b [0]): a.call (c, b [0]); case 2 : devuelve d? a (b [0], b [1]): a.call (c, b [0], b [1]); caso 3: devuelve d? a (b [0], b [1 ], b [2]): a.call (c, b [0], b [1], b [2]); caso 4: devuelve d? a (b [0], b [1], b [ 2], b [3]): a.call (c, b [0], b [1], b [2], b [3])} devuelve a.apply (c, b)}}, {} ], 51: [function (a, b, c) {b.exports = function (a) {return "object" == typeof a? Null! == a: "function" == typeof a}}, {} ], 52: [función (a, b, c) {var d = a ("./_ un-objeto"), e = a ("./_ ie8-dom-define"), f = a ("./ _to-primitivo "), g = Object.defineProperty; cf = a (" ./_ descriptors ")? Object.defineProperty: function (a, b,c) {if (d (a), b = f (b,! 0), d (c), e) intenta {return g (a, b, c)} catch (h) {} if ("get" en c || "conjunto" en c) arroje TypeError ("¡Accesores no compatibles!"); devuelva "valor" en c && (a [b] = c.value), a}}, {"./_ un objeto" : 38, "./_ descriptores": 42, "./_ ie8-dom-define": 49, "./_ to-primitive": 55}], 53: [función (a, b, c) {b.exports = función (a, b) {return {enumerable:! (1 & a), configurable:! (2 & a), de escritura:! (4 & a), valor: b}}}, {}], 54: [función (a, b , c) {var d, e, f, g = a ("./_ ctx"), h = a ("./_ invoke"), i = a ("./_ html"), j = a (". / _dom-create "), k = a (" ./_ global "), l = k.process, m = k.setImmediate, n = k.clearImmediate, o = k.MessageChannel, p = 0, q = {} , r = "onreadystatechange", s = function () {var a = + this; if (q.hasOwnProperty (a)) {var b = q [a]; delete q [a], b ()}}, t = función (a) {s.call (a.data)}; m && n || (m = función (a) {para (var b = [], c = 1; argumentos.length> c;) b.push (argumentos [c ++]); return q [++ p] = function ( ) {h ("function" == typeof a? a: Function (a), b)}, d (p), p}, n = function (a) {delete q [a]}, "process" == a ("./_ cof") (l)? d = función (a) {l.nextTick (g (s, a, 1))}: o? (e = new o, f = e.port2, e. port1.onmessage = t, d = g (f.postMessage, f, 1)): k.addEventListener && "function" == typeof postMessage &&! k.importScripts? (d = function (a) {k.postMessage (a + "" , "*")}, k.addEventListener ("mensaje", t,! 1)): d = r en j ("script")? function (a) {i.appendChild (j ("script")) [ r] = function () {i.removeChild (this), s.call (a)}}: function (a) {setTimeout (g (s, a, 1), 0)}), b.exports = {set : m, claro: n}}, {"./_ cof": 39, "./_ ctx": 41, "./_ dom-create": 43, "./_ global": 46, "./_ html": 48,"./_invoke":50}font>,55:[function(a,b,c){var d = a (" ./_ is-object "); b.exports = function (a, b) {if (! d (a)) devuelve a; var c, e; if (b && "function" == typeof (c = a.toString) &&! d (e = c.call (a))) return e; if ("function "== typeof (c = a.valueOf) &&! d (e = c.call (a))) devuelve e; if (! b &&" function "== typeof (c = a.toString) &&! d (e = c.call (a))) return e; throw TypeError ("No se puede convertir el objeto en valor primitivo")}}, {"./_ es-objeto": 51}], 56: [función (a, b , c) {var d = a ("./_ export"), e = a ("./_ task"); d (d.G + dB, {setImmediate: e.set, clearImmediate: e.clear})} , {"./_ export": 44, "./_ task": 54}], 57: [función (a, b, c) {(función (a) {"use estricto"; función c () {k = ! 0; for (var a, b, c = l.length; c;) {for (b = l, l = [], a = -1; ++ a <c;) b [a] (); c = l.length} k =! 1} función d (a) {1! == l.push (a) || k || e ()} var e, f = a.MutationObserver || a.WebKitMutationObserver; if (f) {var g = 0, h = new f (c), i = a.document .createTextNode (""); h.observe (i, {characterData:! 0}), e = function () {i.data = g = ++ g% 2}} else if (a.setImmediate || "undefined "== typeof a.MessageChannel) e =" document "en un &&" onreadystatechange "en a.document.createElement (" script ")? function () {var b = a.document.createElement (" script "); b. onreadystatechange = function () {c (), b.onreadystatechange = null, b.parentNode.removeChild (b), b = null}, a.document.documentElement.appendChild (b)}: function () {setTimeout (c, 0)}; más {var j = nuevo a.MessageChannel; j.port1.onmessage = c, e = function () {j.port2.postMessage (0)}} var k, l = []; b.exports = d}). call (this, "undefined"! = typeof global? global: "undefined"! = typeof self? self: "undefined"!= typeof window? window: {})}, {}], 58: [función (a, b, c) {"usar estricto"; función d () {} función e (a) {if ("función"! = typeof a) lanzar un nuevo TypeError ("resolver debe ser una función"); this.state = s, this.queue = [], this.outcome = void 0, a! == d && i (this, a)} function f (a, b, c) {this.promise = a, "function" == typeof b && (this.onFulfilled = b, this.callFulfilled = this.otherCallFulfilled), "function" == typeof c && (this.onRejected = c , this.callRejected = this.otherCallRejected)} función g (a, b, c) {o (function () {var d; try {d = b (c)} catch (e) {return p.reject (a, e)} d === a? p.reject (a, new TypeError ("No se puede resolver la promesa consigo mismo")): p.resolve (a, d)})} función h (a) {var b = a && a. entonces; if (a && "object" == typeof a && "function" == typeof b) return function () {b.apply (a, argumentos)}} function i (a,b) {función c (b) {f || (f =! 0, p.reject (a, b))} función d (b) {f || (f =! 0, p.resolve (a, b ))} función e () {b (d, c)} var f =! 1, g = j (e); "error" === g.status && c (g.value)} función j (a, b) {var c = {}; prueba {c.value = a (b), c.status = "success"} catch (d) {c.status = "error", c.value = d} return c} function k (a) {devolver una instancia de esto? a: p.resolve (new this (d), a)} function l (a) {var b = new this (d); return p.reject (b, a)} function m (a) {función b (a, b) {función d (a) {g [b] = a, ++ h! == e || f || (f =! 0, p.resolve (j, g))} c.resolver (a) .then (d, función (a) {f || (f =! 0, p.reject (j, a))})} var c = this; if ("[ object Array] "! == Object.prototype.toString.call (a)) devuelve this.reject (new TypeError (" debe ser una matriz ")); var e = a.length, f =! 1; if (! e) devuelve this.resolve ([]); for (var g = new Array (e), h = 0, i = -1, j = new this (d); ++ i <e;) b (a [ i], i); devuelve j} función n (a) {función b (a) {c.resolve (a).entonces (función (a) {f || (f =! 0, p.resolve (h, a))}, función (a) {f || (f =! 0, p.reject (h, a)) })} var c = this; if ("[object Array]"! == Object.prototype.toString.call (a)) devuelve this.reject (new TypeError ("debe ser una matriz")); var e = a.length, f =! 1; if (! e) devuelve this.resolve ([]); for (var g = -1, h = new this (d); ++ g <e;) b (a [ g]); devuelve h} var o = a ("inmediato"), p = {}, q = ["RECHAZADO"], r = ["CUMPLIDO"], s = ["PENDIENTE"]; b.exports = e, e.prototype ["catch"] = function (a) {return this.then (null, a)}, e.prototype.then = function (a, b) {if ("function"! = typeof a && this. state === r || "function"! = typeof b && this.state === q) devuelve this; var c = new this.constructor (d); if (this.state! == s) {var e = this .state === r? a: b; g (c, e, this.outcome)} else this.queue.push (new f (c, a, b)); return c}, f.prototype.callFulfilled = función (a) {p.resolver (this.promise, a)}, f.prototype.otherCallFulfilled = function (a) {g (this.promise, this.onFulfilled, a)}, f.prototype.callRejected = function (a) {p.reject ( this.promise, a)}, f.prototype.otherCallRejected = function (a) {g (this.promise, this.onRejected, a)}, p.resolve = function (a, b) {var c = j (h , b); if ("error" === c.status) devuelve p.reject (a, c.value); var d = c.value; if (d) i (a, d); else {a. state = r, a.outcome = b; for (var e = -1, f = a.queue.length; ++ e <f;) a.queue [e] .callFulfilled (b)} return a}, p .reject = function (a, b) {a.state = q, a.outcome = b; for (var c = -1, d = a.queue.length; ++ c <d;) a.queue [c ] .callRejected (b); devuelve a}, e.resolve = k, e.reject = l, e.all = m, e.race = n}, {inmediato: 57}], 59: [función (a, b, c) {"use estricto"; var d = a ("./ lib / utils / common"). asignar, e = a ("./ lib / deflate"), f = a ("./ lib / inflar "), g = a (" ./ lib / zlib / constants "), h = {}; d (h, e, f, g), b.exportaciones = h}, {"./ lib / deflate": 60, "./ lib / inflate": 61, "./ lib / utils / common": 62, "./ lib / zlib / constants": 65} ], 60: [función (a, b, c) {"usar estricto"; función d (a) {if (! (This instanceof d)) return new d (a); this.options = i.assign ({ nivel: s, método: u, chunkSize: 16384, windowBits: 15, memLevel: 8, estrategia: t, to: ""}, a || {}); var b = this.options; b.raw && b.windowBits> 0? B.windowBits = -b.windowBits: b.gzip && b.windowBits> 0 && b.windowBits <16 && (b.windowBits + = 16), this.err = 0, this.msg = "", this.ended =! 1, this.chunks = [], this.strm = new l, this.strm.avail_out = 0; var c = h.deflateInit2 (this.strm, b.level, b.method, b.windowBits, b.memLevel, b .strategy); if (c! == p) arroja un nuevo error (k [c]); if (b.header && h.deflateSetHeader (this.strm, b.header), b.dictionary) {var e; if (e = "cadena" == typeof b.diccionario? j.string2buf (b.dictionary): "[object ArrayBuffer]" === m.call (b.dictionary)? new Uint8Array (b.dictionary): b.dictionary, c = h.deflateSetDictionary (this.strm , e), c! == p) arroja un nuevo error (k [c]); this._dict_set =! 0}} función e (a, b) {var c = new d (b); if (c.push (a,! 0), c.err) arroje c.msg; devuelve c.resultado} función f (a, b) {retorno b = b || {}, b.raw =! 0, e (a, b )} función g (a, b) {return b = b || {}, b.gzip =! 0, e (a, b)} var h = a ("./ zlib / deflate"), i = a ("./utils/common"),j=a("./utils/strings"),k=a("./zlib/messages"),l=a("./zlib/zstream"),m = Object.prototype.toString, n = 0, o = 4, p = 0, q = 1, r = 2, s = -1, t = 0, u = 8; d.prototype.push = function (a, b) {var c, d, e = this.strm, f = this.options.chunkSize; if (this.ended) return! 1; d = b === ~~ b? b: b ===! 0 ? o: n, "string" == typeof a? e.input = j.string2buf (a): "[object ArrayBuffer]" === m.call (a)? e.input = new Uint8Array (a): e.input = a, e.next_in = 0, e.avail_in = e.input.length; do {if (0 === e.avail_out && (e.output = new i.Buf8 (f), e.next_out = 0, e.avail_out = f), c = h.deflate (e, d), c! == q && c! == p) devuelve this.onEnd (c), this.ended = ! 0,! 1; 0! == e.avail_out && (0! == e.avail_in || d! == o && d! == r) || ("string" === this.options.to?this. onData (j.buf2binstring (i.shrinkBuf (e.output, e.next_out))): this.onData (i.shrinkBuf (e.output, e.next_out)))} while ((e.avail_in> 0 || 0 === e.avail_out) && c! == q); return d === o? (C = h.deflateEnd (this.strm), this.onEnd (c), this.ended =! 0, c = == p): d! == r || (this.onEnd (p), e.avail_out = 0,! 0)}, d.prototype.onData = function (a) {this.chunks.push (a) }, d.prototype.onEnd = function (a) {a === p && ("string" === this.options.to?this.result=this.chunks.join(""):this.result=i .flattenChunks (this.chunks)), this.chunks = [], esto.err = a, this.msg = this.strm.msg}, c.Deflate = d, c.deflate = e, c.deflateRaw = f, c.gzip = g}, {"./ utils / common": 62 , "./ utils / strings": 63, "./ zlib / deflate": 67, "./ zlib / messages": 72, "./ zlib / zstream": 74}], 61: [función (a, b, c) {"use estricto"; función d (a) {if (! (esta instancia de d)) devuelve nuevo d (a); this.options = h.assign ({chunkSize: 16384, windowBits: 0, to : ""}, a || {}); var b = this.options; b.raw && b.windowBits> = 0 && b.windowBits <16 && (b.windowBits = -b.windowBits, 0 === b.windowBits && (b .windowBits = -15)),! (b.windowBits> = 0 && b.windowBits <16) || a && a.windowBits || (b.windowBits + = 32), b.windowBits> 15 && b.windowBits <48 && 0 === (15 & b .windowBits) && (b.windowBits | = 15), this.err = 0, this.msg = "", this.ended =! 1, this.chunks = [], this.strm = new l, this.strm.avail_out = 0; var c = g.inflateInit2 (this.strm, b.windowBits); if (c! == j.Z_OK) arroja un nuevo error (k [c]); this.header = new m, g .inflateGetHeader (this.strm, this.header)} función e (a, b) {var c = new d (b); if (c.push (a,! 0), c.err) throw c.msg; return c.result} function f (a, b) {return b = b || {}, b.raw =! 0, e (a, b)} var g = a ("./ zlib / inflate"), h = a ("./ utils / common"), i = a ("./ utils / strings"), j = a ("./ zlib / constants"), k = a ("./ zlib / messages" ), l = a ("./ zlib / zstream"), m = a ("./ zlib / gzheader"), n = Object.prototype.toString; d.prototype.push = function (a, b) {var c, d, e, f, k, l, m = this.strm, o = this.options.chunkSize, p = this.options.dictionary, q =! 1; if (this.ended) return! 1; d = b === ~~ b? b: b ===! 0? j.Z_FINISH: j.Z_NO_FLUSH, "string" == typeof a? m.input = i.binstring2buf (a): "[object ArrayBuffer] "=== n.call (a)? m.input = new Uint8Array (a): m.input = a, m.next_in = 0, m.avail_in = m.input.length; do {if (0 === m.avail_out && (m.output = new h.Buf8 (o), m.next_out = 0, m.avail_out = o), c = g.inflate (m, j.Z_NO_FLUSH), c === j.Z_NEED_DICT && p && (l = "string" == typeof p? i.string2buf (p): "[object ArrayBuffer] "=== n.call (p)? new Uint8Array (p): p, c = g.inflateSetDictionary (this.strm, l)), c === j.Z_BUF_ERROR && q ===! 0 && (c = j. Z_OK, q =! 1), c! == j.Z_STREAM_END && c! == j.Z_OK) devuelve this.onEnd (c), this.ended =! 0,! 1; m.next_out && (0! == m. avail_out && c! == j.Z_STREAM_END && (0! == m.avail_in || d! == j.Z_FINISH && d! == j.Z_SYNC_FLUSH) || ("string" === this.options.to?(e=i .utf8border (m.output, m.next_out), f = m.next_out-e, k = i.buf2string (m.output, e), m.next_out = f, m.avail_out = of, f && h.arraySet (m .output, m.output, e, f, 0), this.onData (k)): this.onData (h.shrinkBuf (m.output, m.next_out)))), 0 === m.avail_in && 0 === m.avail_out && (q =! 0)} while ((m.avail_in> 0 || 0 === m.avail_out) && c! == j.Z_STREAM_END); devuelve c === j.Z_STREAM_END && (d = j.Z_FINISH), d === j.Z_FINISH? (c = g.inflateEnd (this.strm), this.onEnd (c), this.ended =! 0, c === j.Z_OK): d! == j.Z_SYNC_FLUSH || (this.onEnd (j.Z_OK), m.avail_out = 0,! 0)}, d.prototype. onData = function (a) {this.chunks.push (a)}, d.prototype.onEnd = function (a) {a === j.Z_OK && ("string" === this.options.to?this. resultado = this.chunks.join (""): this.result = h.flattenChunks (this.chunks)), this.chunks = [], this.err = a, this.msg = this.strm.msg}, c.Inflate = d, c.inflate = e, c.inflateRaw = f, c.ungzip = e}, {"./ utils / common": 62, "./ utils / strings": 63, "./ zlib /constants":65,"./zlib/gzheader":68,"./zlib/inflate":70,"./zlib/messages":72, "./ zlib / zstream ": 74}], 62: [function (a, b, c) {" use estricto "; var d =" undefined "! = typeof Uint8Array &&" undefined "! = typeof Uint16Array &&" undefined "! = typeof Int32Array; c.assign = function (a) {for (var b = Array.prototype.slice.call (argumentos, 1); b.length;) {var c = b.shift (); if (c) {if ("object"! = typeof c) throw new TypeError (c + "debe ser no-object"); for (var d in c) c.hasOwnProperty (d) && (a [d] = c [d])}} return a}, c.shrinkBuf = function (a, b) {return a.length === b? a: a.subarray? a.subarray (0, b) :( a.length = b, a)}; var e = {arraySet: function (a, b, c, d, e) {if (b.subarray && a.subarray) return void a.set (b.subarray (c, c + d), e); for (var f = 0; f <d; f ++) a [e + f] = b [c + f]}, flattenChunks: función (a) {var b, c, d, e, f, g; para (d = 0 , b = 0, c = a.length; b <c; b ++) d + = a [b] .length; for (g = new Uint8Array (d), e = 0, b = 0, c = a.length; b <c;b ++) f = a [b], g.set (f, e), e + = f.length; return g}}, f = {arraySet: function (a, b, c, d, e) {for (var f = 0; f <d; f ++) a [e + f] = b [c + f]}, flattenChunks: función (a) {return []. concat.apply ([], a)}}; c. setTyped = function (a) {a? (c.Buf8 = Uint8Array, c.Buf16 = Uint16Array, c.Buf32 = Int32Array, c.assign (c, e)) :( c.Buf8 = Array, c.Buf16 = Array , c.Buf32 = Array, c.assign (c, f))}, c.setTyped (d)}, {}], 63: [función (a, b, c) {"usar estricto"; función d ( a, b) {if (b <65537 && (a.subarray && g ||! a.subarray && f)) devuelve String.fromCharCode.apply (null, e.shrinkBuf (a, b)); for (var c = "", d = 0; d <b; d ++) c + = String.fromCharCode (a [d]); return c} var e = a ("./ common"), f =! 0, g =! 0; try {String. fromCharCode.apply (nulo, [0])} catch (h) {f =! 1} intente {String.fromCharCode.apply (nulo, nuevo Uint8Array (1))} catch (h) {g =! 1} para ( var i = nuevo e.Buf8 (256), j = 0; j <256; j ++) i [j] = j> = 252? 6: j> = 248? 5: j> = 240? 4: j>= 224? 3: j> = 192? 2: 1; i [254] = i [254] = 1, c.string2buf = función (a) {var b, c, d, f, g, h = a. longitud, i = 0; para (f = 0; f <h; f ++) c = a.charCodeAt (f), 55296 === (64512 & c) && f + 1 <h && (d = a.charCodeAt (f + 1) , 56320 === (64512 & d) && (c = 65536 + (c-55296 << 10) + (d-56320), f ++)), i + = c <128? 1: c <2048? 2: c <65536 ? 3: 4; para (b = nuevo e.Buf8 (i), g = 0, f = 0; g <i; f ++) c = a.charCodeAt (f), 55296 === (64512 & c) && f + 1 <h && (d = a.charCodeAt (f + 1), 56320 === (64512 & d) && (c = 65536 + (c-55296 << 10) + (d-56320), f ++)), c <128? b [g ++] = c: c <2048? (b [g ++] = 192 | c >>> 6, b [g ++] = 128 | 63 & c): c <65536? (b [g ++] = 224 | c >> > 12, b [g ++] = 128 | c >>> 6 y 63, b [g ++] = 128 | 63 & c) :( b [g ++] = 240 | c >>> 18, b [g ++] = 128 | c >> > 12 y 63, b [g ++] = 128 | c >>> 6 y 63, b [g ++] = 128 | 63 y c); return b}, c.buf2binstring = function (a) {return d (a, a.length)}, c.binstring2buf = function (a) {for (var b = new e.Buf8 (a.length), c = 0, d = b.length; c <d; c ++) b [c] = a .charCodeAt (c); return b}, c.buf2string = function (a, b) {var c, e, f, g, h = b || a.length, j = new Array (2 * h); para (e = 0, c = 0; c <h;) if (f = a [c ++], f <128) j [e ++] = f; sino if (g = i [f], g> 4) j [ e ++] = 65533, c + = g-1; más {para (f & = 2 === g? 31: 3 === g? 15: 7; g> 1 && c <h;) f = f << 6 | 63 & a [c ++], g -; g> 1? j [e ++] = 65533: f <65536? j [e ++] = f: (f- = 65536, j [e ++] = 55296 | f >> 10 y 1023, j [ e ++] = 56320 | 1023 & f)} return d (j, e)}, c.utf8border = function (a, b) {var c; for (b = b || a.length, b> a.length && (b = a.length), c = b-1; c> = 0 && 128 === (192 & a [c]);) c -; return c <0? b: 0 === c? b: c + i [a [c]]> b? c: b}}, {"./ común": 62}], 64: [función (a, b, c) {"usar estricto"; función d (a, b, c, d) {para (var e = 65535 & a | 0, f = a >>> 16 & 65535 | 0, g = 0; 0! == c;) {g = c> 2e3? 2e3: c,c- = g; do e = e + b [d ++] | 0, f = f + e | 0; while (- g); e% = 65521, f% = 65521} return e | f << 16 | 0} b.exports = d}, {}], 65: [función (a, b, c) {"use estricto"; b.exports = {Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3 , Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: ​​1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z__EST ,__SP, Z_STED__COM, Z_STREAM_END: ​​1 : 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILtered: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_}, Z_}}, Z_}, Z_TEXT: 1, Z_} {}], 66: [función (a, b, c) {"usar estricto"; función d () {Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESS_, Z_F_RU, Z_DEFAULT_COMPRIMIDO_, Z_DEFAULT_COMPRIMIDO: 1 : 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8}}, {}], 66: [function (a, b, c) {"use estricto"; función d () {Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESS_, Z_F_RU, Z_DEFAULT_COMPRIMIDO_, Z_DEFAULT_COMPRIMIDO: 1 : 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8}}, {}], 66: [function (a, b, c) {"use estricto"; función d () {
    para (var a, b = [], c = 0; c <256; c ++) {a = c; para (var d = 0; d <8; d ++) a = 1 & a? 3988292384 ^ a >>> 1: a >>> 1; b [c] = a} return b} función e (a, b, c, d) {var e = f, g = d + c; a ^ = - 1; para (var h = d; h <g; h ++) a = a >>> 8 ^ e [255 & (a ^ b [h])]; devuelve a ^ -1} var f = d (); b.exports = e}, { }], 67: [función (a, b, c) {"usar estricto"; función d (a, b) {return a.msg = I [b], b} función e (a) {return (a < <1) - (a> 4? 9: 0)} función f (a) {para (var b = a.length; - b> = 0;) a [b] = 0} función g (a) { var b = a.state, c = b.pending; c> a.avail_out && (c = a.avail_out), 0! == c && (E.arraySet (a.output, b.pending_buf, b.pending_out, c, a.next_out), a.next_out + = c, b.pending_out + = c, a.total_out + = c, a.avail_out- = c, b.pending- = c, 0 === b.pending && (b.pending_out = 0 ))} función h (a, b) {F._tr_flush_block (a, a.block_start> = 0? a.block_start: -1, a.strstart-a.block_start, b), a.block_start = a.strstart, Georgia.strm)} función i (a, b) {a.pending_buf [a.pending ++] = b} función j (a, b) {a.pending_buf [a.pending ++] = b >>> 8 y 255, a.pending_buf [a .pending ++] = 255 & b} función k (a, b, c, d) {var e = a.avail_in; return e> d && (e = d), 0 === e? 0: (a.avail_in- = e , E.arraySet (b, a.input, a.next_in, e, c), 1 === a.state.wrap? a.adler = G (a.adler, b, e, c): 2 === a.state.wrap && (a.adler = H (a.adler, b, e, c)), a.next_in + = e, a.total_in + = e, e)} función l (a, b) {var c, d, e = a.max_chain_length, f = a.strstart, g = a.prev_length, h = a.nice_match, i = a.strstart> a.w_size-la? a.strstart- (a.w_size-la): 0, j = a.window, k = a.w_mask, l = a.prev, m = a.strstart + ka , n = j [f + g-1], o = j [f + g]; a.prev_length> = a.good_match && (e >> = 2), h> a.lookahead && (h = a.lookahead); hacer si (c = b, j [c + g] === o && j [c + g-1] === n && j [c] === j [f] && j [++ c] === j [f +1]) {f + = 2, c ++; do; while (j [++ f] === j [++ c] && j [++ f] === j [++ c] && j [++ f ] === j [++ c] && j [++ f] === j [++ c] && j [++ f] === j [++ c] && j [++ f] === j [++ c] && j [++ f] === j [++ c] && j [++ f] === j [++ c] && f <m); if (d = ka- (mf), f = m-ka, d> g) {if (a.match_start = b, g = d, d> = h) break; n = j [f + g-1], o = j [f + g]} } while ((b = l [b & k])> i && 0!== - e); devuelve g <= a.lookahead? g: a.lookahead} función m (a) {var b, c, d, e, f, g = a.w_size; do {if (e = a.window_size-a.lookahead-a.strstart, a.strstart> = g + (g-la)) {E.arraySet (a.window, a.window, g, g, 0), a.match_start- = g , a.strstart- = g, a.block_start- = g, c = a.hash_size, b = c; do d = a.head [- b], a.head [b] = d> = g? dg : 0; while (- c); c = g, b = c; do d = a.prev [- b], a.prev [b] = d> = g? Dg: 0; while (- c); e + = g} if (0 === a.strm.avail_in) break; if (c = k (a.strm, a.window, a.strstart + a.lookahead, e), a.lookahead + = c, a.lookahead + a.insert> = ja) para (f = a.strstart-a.insert, a.ins_h = a.window [f], a.ins_h = (a.ins_h << a.hash_shift ^ a.window [f + 1]) & a.hash_mask; a.insert && (a.ins_h = (a.ins_h << a.hash_shift ^ a.window [f + ja-1]) & a.hash_mask, a.prev [ f & a.w_mask] = a.head [a.ins_h], a.head [a.ins_h] = f, f ++, a.insert - ,! (a.lookahead + a.insert <ja)););} while (a.lookahead <la && 0! == a.strm.avail_in)} función n (a, b) {var c = 65535; para (c> a.pending_buf_size-5 && (c = a.pending_buf_size-5) ;;) {if (a.lookahead <= 1) {if ( m (a), 0 === a.lookahead && b === J) devuelve ua; if (0 === a.lookahead) break} a.strstart + = a.lookahead, a.lookahead = 0; var d = a .block_start + c; if ((0 === a.strstart || a.strstart> = d) && (a.lookahead = a.strstart-d, a.strstart = d, h (a,! 1), 0 === a.strm.avail_out)) return ua; if (a.strstart-a.block_start> = a.w_size-la && (h (a,! 1), 0 === a.strm.avail_out)) return ua} return a.insert = 0, b === M? (h (a,! 0), 0 === a.strm.avail_out? wa: xa): a.strstart> a.block_start && (h ( a,! 1), 0 === a.strm.avail_out)? ua: ua} función o (a, b) {for (var c, d ;;) {if (a.lookahead <la) {if ( m (a), a.lookahead <la && b === J) devuelve ua; if (0 === a.lookahead) break} if (c = 0, a.lookahead> = ja && (a.ins_h = (a. ins_h << a.hash_shift ^ a.window [a.strstart + ja-1]) & a.hash_mask, c = a.prev [a.strstart & a.w_mask] = a.head [a.ins_h], a.head [a.ins_h] = a.strstart), 0! == c && a.strstart-c <= a .w_size-la && (a.match_length = l (a, c)), a.match_length> = ja) if (d = F._tr_tally (a, a.strstart-a.match_start, a.match_length-ja), a .lookahead- = a.match_length, a.match_length <= a.max_lazy_match && a.lookahead> = ja) {a.match_length -; a.strstart ++, a.ins_h = (a.ins_h << a.hash_shift ^ a. ventana [a.strstart + ja-1]) y a.hash_mask, c = a.prev [a.strstart & a.w_mask] = a.head [a.ins_h], a.head [a.ins_h] = a.strstart; while (0! == - a.match_length); a.strstart ++} else a.strstart + = a.match_length, a.match_length = 0, a.ins_h = a.window [a.strstart], a.ins_h = ( a.ins_h << a.hash_shift ^ a.window [a.strstart + 1]) & a.hash_mask; si no d = F._tr_tally (a, 0, a.window [a.strstart]), a.lookahead-- , a.strstart ++; if (d && (h (a,! 1), 0 === a.strm.avail_out)) return ua} return a.insert = a.strstart <ja-1? a.strstart: ja-1, b === M? (h (a,! 0), 0 === a.strm. avail_out? wa: xa): a.last_lit && (h (a,! 1), 0 === a.strm.avail_out)? ua: va} función p (a, b) {para (var c, d, e ;;) {if (a.lookahead <la) {if (m (a), a.lookahead <la && b === J) devuelve ua; if (0 === a.lookahead) break} if (c = 0 , a.lookahead> = ja && (a.ins_h = (a.ins_h << a.hash_shift ^ a.window [a.strstart + ja-1]) y a.hash_mask, c = a.prev [a.strstart & a.w_mask ] = a.head [a.ins_h], a.head [a.ins_h] = a.strstart), a.prev_length = a.match_length, a.prev_match = a.match_start, a.match_length = ja-1,0 ! == c && a.prev_length <a.max_lazy_match && a.strstart-c <= a.w_size-la && (a.match_length = l (a, c), a.match_length <= 5 && (a.strategy === U || a .match_length === ja && a.strstart-a.match_start> 4096) && (a.match_length = ja-1)), a.prev_length> = ja && a.match_length <= a.prev_length) {e = a.strstart + a.lookahead-ja, d = F._tr_tally (a, a.strstart-1-a.prev_match, a.prev_length-ja), a.lookahead - = a.prev_length-1, a.prev_length- = 2; do ++ a.strstart <= e && (a.ins_h = (a.ins_h << a.hash_shift ^ a.window [a.strstart + ja-1 ]) & a.hash_mask, c = a.prev [a.strstart & a.w_mask] = a.head [a.ins_h], a.head [a.ins_h] = a.strstart); while (0! == - a.prev_length); if (a.match_available = 0, a.match_length = ja-1, a.strstart ++, d && (h (a,! 1), 0 === a.strm.avail_out)) return ua} else if (a.match_available) {if (d = F._tr_tally (a, 0, a.window [a.strstart-1]), d && h (a,! 1), a.strstart ++, a.lookahead -, 0 === a.strm.avail_out) return ua} más a.match_available = 1, a.strstart ++, a.lookahead -} return a.match_available && (d = F._tr_tally (a, 0, a.window [a. strstart-1]), a.match_available = 0), a.insert = a.strstart <ja-1? a.strstart: ja-1, b === M? (h (a,! 0),0 === a.strm.avail_out? Wa: xa): a.last_lit && (h (a,! 1), 0 === a.strm.avail_out)? Ua: va} función q (a, b) { para (var c, d, e, f, g = a.window ;;) {if (a.lookahead <= ka) {if (m (a), a.lookahead <= ka && b === J) return ua ; if (0 === a.lookahead) break} if (a.match_length = 0, a.lookahead> = ja && a.strstart> 0 && (e = a.strstart-1, d = g [e], d == = g [++ e] && d === g [++ e] && d === g [++ e])) {f = a.strstart + ka; do; while (d === g [++ e] && d === g [++ e] && d === g [++ e] && d === g [++ e] && d === g [++ e] && d === g [++ e] && d === g [++ e] && d === g [++ e] && e <f); a.match_length = ka- (fe), a.match_length> a.lookahead && (a.match_length = a .lookahead)} if (a.match_length> = ja? (c = F._tr_tally (a, 1, a.match_length-ja), a.lookahead- = a.match_length, a.strstart + = a.match_length, a. match_length = 0) :( c = F._tr_tally (a, 0, a.window [a.strstart]), a.lookahead -, a.strstart ++), c && (h (a,! 1), 0 === a.strm.avail_out)) return ua} return a.insert = 0, b === M? (h (a,! 0), 0 === a.strm.avail_out? wa: xa): a.last_lit && (h (a,! 1), 0 === a.strm.avail_out)? ua: va} función r (a, b) {para (var c ;;) {if (0 === a.lookahead && (m (a), 0 === a.lookahead)) {if (b === J) devuelve ua; break} if (a.match_length = 0, c = F._tr_tally (a, 0, a.window [a.strstart]), a.lookahead -, a.strstart ++, c && (h (a,! 1), 0 === a.strm .avail_out)) return ua} return a.insert = 0, b === M? (h (a,! 0), 0 === a.strm.avail_out? wa: xa): a.last_lit && (h ( a,! 1), 0 === a.strm.avail_out)? ua: va} función s (a, b, c, d, e) {this.good_length = a, this.max_lazy = b, this.nice_length = c, this.max_chain = d, this.func = e} función t (a) {a.window_size = 2 * a.w_size, f (a.head), a.max_lazy_match = D [a.level] .max_lazy , a.good_match = D [a.level] .good_length, a.nice_match = D [a.level] .nice_length, a.max_chain_length = D [a.level] .max_chain, a.strstart = 0, a.block_start = 0, a.lookahead = 0, a.insert = 0, a.match_length = a.prev_length = ja-1, a.match_available = 0, a.ins_h = 0} function u () {this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this .gzindex = 0, this.method = $, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this. prev = nulo, this.head = nulo, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new E.Buf16 (2 * ha), this.dyn_dtree = new E.Buf16 (2 * ( 2 * fa + 1)), this.bl_tree = new E.Buf16 (2 * (2 * ga + 1)), f (this.dyn_ltree), f (this.dyn_dtree), f (this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = nulo, this.bl_count = new E.Buf16 (ia + 1), this.heap = new E.Buf16 (2 * ea + 1), f (this.heap), this.heap_len = 0, this.heap_max = 0 , this.depth = new E.Buf16 (2 * ea + 1), f (this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this. opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0} función v (a) {var b; devuelve un && a.state? (a .total_in = a.total_out = 0, a.data_type = Z, b = a.state, b.pending = 0, b.pending_out = 0, b.wrap <0 && (b.wrap = -b.wrap), b .status = b.wrap? na: sa, a.adler = 2 === b.wrap? 0: 1, b.last_flush = J, F._tr_init (b), O): d (a, Q)} function w (a) {var b = v (a); return b === O && t (a.state), b} function x (a, b) {return a && a.state? 2! == a.state.wrap ? Q: (a.state.gzhead = b, O): Q} función y (a, b, c, e, f, g) {if (! A) devuelve Q;var h = 1; if (b === T && (b = 6), e <0? (h = 0, e = -e): e> 15 && (h = 2, e- = 16), f <1 || f> _ || c! == $ || e <8 || e> 15 || b <0 || b> 9 || g <0 || g> X) retorno d (a, Q) ; 8 === e && (e = 9); var i = new u; return a.state = i, i.strm = a, i.wrap = h, i.gzhead = null, i.w_bits = e, i .w_size = 1 << i.w_bits, i.w_mask = i.w_size-1, i.hash_bits = f + 7, i.hash_size = 1 << i.hash_bits, i.hash_mask = i.hash_size-1, i .hash_shift = ~~ ((i.hash_bits + ja-1) / ja), i.window = new E.Buf8 (2 * i.w_size), i.head = new E.Buf16 (i.hash_size), i .prev = new E.Buf16 (i.w_size), i.lit_bufsize = 1 << f + 6, i.pending_buf_size = 4 * i.lit_bufsize, i.pending_buf = new E.Buf8 (i.pending_buf_size), i. d_buf = 1 * i.lit_bufsize, i.l_buf = 3 * i.lit_bufsize, i.level = b, i.strategy = g, i.method = c, w (a)} función z (a, b) {return y (a, b, $, aa, ba, Y)} función A (a, b) {var c, h, k, l; if (! a ||! a.state || b> N || b <0) devuelve a? D (a, Q): Q; if (h = a.state,! A.output ||! A.input && 0! == a.avail_in || h.status === ta && b! == M) return d (a, 0 === a.avail_out? S: Q); if (h.strm = a, c = h .last_flush, h.last_flush = b, h.status === na) if (2 === h.wrap) a.adler = 0, i (h, 31), i (h, 139), i (h , 8), h.gzhead? (I (h, (h.gzhead.text? 1: 0) + (h.gzhead.hcrc? 2: 0) + (h.gzhead.extra? 4: 0) + ( h.gzhead.name?8:0)+(h.gzhead.comment?16:0)),i(h,255&h.gzhead.time),i(h,h.gzhead.time>>8&255),i (h, h.gzhead.time >> 16 y 255), i (h, h.gzhead.time >> 24 y 255), i (h, 9 === h.level? 2: h.strategy> = V || h .level <2? 4: 0), i (h, 255 & h.gzhead.os), h.gzhead.extra && h.gzhead.extra.length && (i (h, 255 & h.gzhead.extra.length), i (h, h.gzhead.extra.length >> 8 y 255)), h.gzhead.hcrc && (a.adler = H (a.adler, h.pending_buf, h.pending, 0)), h.gzindex = 0, h.status = oa) :( i (h, 0), i (h, 0), i (h, 0), i (h, 0), i (h, 0), i (h, 9 === h. nivel? 2: h.strategy> = V || h.level <2? 4: 0), i (h, ya), h.status = sa); else {var m = $ + (h.w_bits-8 << 4) << 8, n = -1; n = h.strategy> = V || h.level <2? 0: h .level <6? 1: 6 === h.level? 2: 3, m | = n << 6,0! == h.strstart && (m | = ma), m + = 31-m% 31, h .status = sa, j (h, m), 0! == h.strstart && (j (h, a.adler >>> 16), j (h, 65535 & a.adler)), a.adler = 1} si (h.status === oa) if (h.gzhead.extra) {for (k = h.pending; h.gzindex <(65535 & h.gzhead.extra.length) && (h.pending! == h.pending_buf_size || (h.gzhead.hcrc && h.pending> k && (a.adler = H (a.adler, h.pending_buf, h.pending-k, k)), g (a), k = h.pending, h. pendiente! == h.pending_buf_size));) i (h, 255 & h.gzhead.extra [h.gzindex]), h.gzindex ++; h.gzhead.hcrc && h.pending> k && (a.adler = H (a.adler , h.pending_buf, h.pending-k, k)), h.gzindex === h.gzhead.extra.length && (h.gzindex = 0, h.status = pa)} else h.status = pa; if (h.status === pa) if (h.gzhead.name) {k = h.pending;do {if (h.pending === h.pending_buf_size && (h.gzhead.hcrc && h.pending> k && (a.adler = H (a.adler, h.pending_buf, h.pending-k, k)), g ( a), k = h.pending, h.pending === h.pending_buf_size)) {l = 1; break} l = h.gzindex <h.gzhead.name.length? 255 & h.gzhead.name.charCodeAt (h .gzindex ++): 0, i (h, l)} while (0! == l); h.gzhead.hcrc && h.pending> k && (a.adler = H (a.adler, h.pending_buf, h.pending- k, k)), 0 === l && (h.gzindex = 0, h.status = qa)} else h.status = qa; if (h.status === qa) if (h.gzhead.comment) {k = h.pending; do {if (h.pending === h.pending_buf_size && (h.gzhead.hcrc && h.pending> k && (a.adler = H (a.adler, h.pending_buf, h.pending-k , k)), g (a), k = h.pending, h.pending === h.pending_buf_size)) {l = 1; break} l = h.gzindex <h.gzhead.comment.length? 255 & h. gzhead.comment.charCodeAt (h.gzindex ++): 0, i (h, l)} while (0! == l); h.gzhead.hcrc && h.pending>k && (a.adler = H (a.adler, h.pending_buf, h.pending-k, k)), 0 === l && (h.status = ra)} else h.status = ra; if (h. status === ra && (h.gzhead.hcrc? (h.pending + 2> h.pending_buf_size && g (a), h.pending + 2 <= h.pending_buf_size && (i (h, 255 & a.adler), i (h, a.adler >> 8 y 255), a.adler = 0, h.status = sa)): h.status = sa), 0! == h.pending) {if (g (a), 0 === a .avail_out) return h.last_flush = -1, O} else if (0 === a.avail_in && e (b) <= e (c) && b! == M) return d (a, S); if (h. status === ta && 0! == a.avail_in) return d (a, S); if (0! == a.avail_in || 0! == h.lookahead || b! == J && h.status! == ta) {var o = h.strategy === V? r (h, b): h.strategy === W? q (h, b): D [h.level] .func (h, b); if (o! == wa && o! == xa || (h.status = ta), o === ua || o === wa) devuelve 0 === a.avail_out && (h.last_flush = -1) , O; if (o === va && (b === K? F._tr_align (h): b! == N && (F._tr_stored_block (h, 0,0,! 1),b === L && (f (h.head), 0 === h.lookahead && (h.strstart = 0, h.block_start = 0, h.insert = 0))), g (a), 0 == = a.avail_out)) return h.last_flush = -1, O} return b! == M? O: h.wrap <= 0? P: (2 === h.wrap? (i (h, 255 & a. adler), i (h, a.adler >> 8 y 255), i (h, a.adler >> 16 y 255), i (h, a.adler >> 24 y 255), i (h, 255 y a.total_in), i ( h, a.total_in >> 8 y 255), i (h, a.total_in >> 16 y 255), i (h, a.total_in >> 24 y 255)) :( j (h, a.adler >>> 16), j (h, 65535 & a.adler)), g (a), h.wrap> 0 && (h.wrap = -h.wrap), 0! == h.pending? O: P)} función B (a) {var b; devuelve un && a.state? (b = a.state.status, b! == na && b! == oa && b! == pa && b! == qa && b! == ra && b! == sa && b! == ta? d (a, Q) :( a.state = null, b === sa? D (a, R): O)): Q} función C (a, b) {var c, d, e, g, h, i, j, k, l = longitud b; if (! a ||! a.state) devuelve Q; if (c = a.state, g = c.wrap, 2 === g || 1 === g && c.status! == na || c.lookahead) devuelve Q; para (1 === g && (a.adler = G (a.adler, b, l, 0)), c.wrap = 0, l> = c.w_size && (0 === g && (f (c.head), c.strstart = 0, c.block_start = 0, c.insert = 0), k = new E.Buf8 (c.w_size), E .arraySet (k, b, lc.w_size, c.w_size, 0), b = k, l = c.w_size), h = a.avail_in, i = a.next_in, j = a.input, a.avail_in = l, a.next_in = 0, a.input = b, m (c); c.lookahead> = ja;) {d = c.strstart, e = c.lookahead- (ja-1); do c. ins_h = (c.ins_h << c.hash_shift ^ c.window [d + ja-1]) & c.hash_mask, c.prev [d & c.w_mask] = c.head [c.ins_h], c.head [c .ins_h] = d, d ++; while (- e); c.strstart = d, c.lookahead = ja-1, m (c)} return c.strstart + = c.lookahead, c.block_start = c.strstart , c.insertar = c.lookahead, c.lookahead = 0, c.match_length = c.prev_length = ja-1, c.match_available = 0, a.next_in = i, a.input = j, a.avail_in = h , c.wrap = g, O} var D, E = a ("../ utils / common"), F = a ("./ trees"), G = a ("./ adler32"),H = a ("./ crc32"), I = a ("./ messages"), J = 0, K = 1, L = 3, M = 4, N = 5, O = 0, P = 1, Q = -2, R = -3, S = -5, T = -1, U = 1, V = 2, W = 3, X = 4, Y = 0, Z = 2, $ = 8, _ = 9, aa = 15, ba = 8, ca = 29, da = 256, ea = da + 1 + ca, fa = 30, ga = 19, ha = 2 * ea + 1, ia = 15, ja = 3, ka = 258, la = ka + ja + 1, ma = 32, na = 42, oa = 69, pa = 73, qa = 91, ra = 103, sa = 113, ta = 666, ua = 1, va = 2, wa = 3, xa = 4, ya = 3; D = [nueva s (0,0,0,0, n), nueva s (4,4,8,4, o), nueva s (4, 5,16,8, o), nueva s (4,6,32,32, o), nueva s (4,4,16,16, p), nueva s (8,16,32,32, p) , nueva s (8,16,128,128, p), nueva s (8,32,128,256, p), nueva s (32,128,258,1024, p), nueva s (32,258,258,4096, p)], c.deflateInit = z, c. deflateInit2 = y, c.deflateReset = w, c.deflateResetKeep = v, c.deflateSetHeader = x, c.deflate = A, c.deflateEnd = B, c.deflateSetDictionary = C, c.deflateInfo = "pako deflate (de Nodeca proyecto) "}, {" ../ utils / common ": 62," ./ adler32 ": 64," ./ crc32 ": 66," ./ messages ": 72," ./ trees ": 73}] , 68: [función (a, b,c) {"use estricto"; función d () {this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this .name = "", this.comment = "", this.hcrc = 0, this.done =! 1} b.exports = d}, {}], 69: [función (a, b, c) {" use estricto "; var d = 30, e = 12; b.exports = function (a, b) {var c, f, g, h, i, j, k, l, m, n, o, p, q , r, s, t, u, v, w, x, y, z, A, B, C; c = a.state, f = a.next_in, B = a.input, g = f + (a.avail_in -5), h = a.next_out, C = a.output, i = h- (ba.avail_out), j = h + (a.avail_out-257), k = c.dmax, l = c.wsize, m = c.whave, n = c.wnext, o = c.window, p = c.hold, q = c.bits, r = c.lencode, s = c.distcode, t = (1 << c.lenbits ) -1, u = (1 << c.distbits) -1; a: do {q <15 && (p + = B [f ++] << q, q + = 8, p + = B [f ++] << q, q + = 8), v = r [p & t]; b: para (;;) {if (w = v >>> 24, p >>> = w, q- = w, w = v >>> 16 y 255,0 === w) C [h ++] = 65535 & v; más {if (! (16 & w)) {if (0 === (64 & w)) {v = r [(65535 & v) + (p &(1 << w) -1)]; continuar b} if (32 & w) {c.mode = e; break a} a.msg = "código de longitud / literal no válido", c.mode = d; break a} x = 65535 & v, w & = 15, w && (q <w && (p + = B [f ++] << q, q + = 8), x + = p & (1 << w) -1, p >>> = w, q- = w), q <15 && (p + = B [f ++] << q, q + = 8, p + = B [f ++] << q, q + = 8), v = s [p & u]; c: para (;;) {if (w = v >>> 24, p >>> = w, q- = w, w = v >>> 16 y 255,! (16 & w)) {if (0 === (64 & w)) {v = s [(65535 & v) + (p & (1 << w) -1)]; continuar c} a.msg = "código de distancia no válido", c.mode = d; romper a} if (y = 65535 & v, w & = 15 , q <w && (p + = B [f ++] << q, q + = 8, q <w && (p + = B [f ++] << q, q + = 8)), y + = p & (1 << w) -1 , y> k) {a.msg = "distancia no válida demasiado atrás", c.mode = d; interrumpa a} if (p >>> = w, q- = w, w = hi, y> w) { if (w = yw, w> m && c.sane) {a.msg = "distancia inválida demasiado atrás ", modo c = d; rompa a} if (z = 0, A = o, 0 === n) {if (z + = lw, w <x) {x- = w; do C [h ++] = o [z ++]; while (- w); z = hy, A = C}} más si (n <w) {if (z + = l + nw, w- = n, w <x ) {x- = w; do C [h ++] = o [z ++]; while (- w); if (z = 0, n <x) {w = n, x- = w; do C [h ++] = o [z ++]; while (- w); z = hy, A = C}}} más si (z + = nw, w <x) {x- = w; do C [h ++] = o [z ++] ; while (- w); z = hy, A = C} para (; x> 2;) C [h ++] = A [z ++], C [h ++] = A [z ++], C [h ++] = A [z ++], x- = 3; x && (C [h ++] = A [z ++], x> 1 && (C [h ++] = A [z ++]))} else {z = hy; do C [h ++] = C [z ++], C [h ++] = C [z ++], C [h ++] = C [z ++], x- = 3; while (x> 2); x && (C [h ++] = C [z ++], x> 1 && (C [h ++] = C [z ++]))} break}} break}} while (f <g && h <j); x = q >> 3, f- = x, q- = x << 3, p & = (1 << q) -1, a.next_in = f, a.next_out = h, a.avail_in = f <g? 5+ (gf): 5- (fg), a.avail_out = h <j? 257+ (jh): 257- (hj), c.hold = p, c.bits = q}}, {}], 70: [función (a, b, c) {"use estricto";función d (a) {return (a >>> 24 y 255) + (a >>> 8 y 65280) + ((65280 & a) << 8) + ((255 & a) << 24)} función e () {this.mode = 0, this.last =! 1, this.wrap = 0, this.havedict =! 1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = nulo, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this. ndist = 0, this.have = 0, this.next = null, this.lens = new s.Buf16 (320), this.work = new s.Buf16 (288), this.lendyn = null, this.distdyn = nulo, this.sane = 0, this.back = 0, this.was = 0} función f (a) {var b; devolver a && a.state? (b = a.state, a.total_in = a.total_out = b .total = 0, a.msg = "", b.wrap && (a.adler = 1 & b.wrap), b.mode = L, b.last = 0, b.havedict = 0, b.dmax = 32768, b .head = nulo, b.hold = 0,b.bits = 0, b.lencode = b.lendyn = nuevo s.Buf32 (pa), b.distcode = b.distdyn = nuevo s.Buf32 (qa), b.sane = 1, b.back = -1 , D): G} ​​función g (a) {var b; devuelve un && a.state? (B = a.state, b.wsize = 0, b.whave = 0, b.wnext = 0, f (a)) : G} función h (a, b) {var c, d; devuelve un && a.state? (D = a.state, b <0? (C = 0, b = -b) :( c = (b >> 4) + 1, b <48 && (b & = 15)), b && (b <8 || b> 15)? G: (null! == d.window && d.wbits! == b && (d.window = null) , d.wrap = c, d.wbits = b, g (a))): G} ​​función i (a, b) {var c, d; devuelve a? (d = new e, a.state = d, d.window = null, c = h (a, b), c! == D && (a.state = null), c): G} ​​función j (a) {return i (a, sa)} función k ( a) {if (ta) {var b; for (q = new s.Buf32 (512), r = new s.Buf32 (32), b = 0; b <144;) a.lens [b ++] = 8 ; para (; b <256;) a.lens [b ++] = 9; for (; b <280;) a.lens [b ++] = 7; for (; b <288;) a.lens [b ++] = 8; para (w (y, a.lens, 0,288, q, 0, a.work, {bits: 9}), b = 0; b <32;) a.lens [b ++] = 5; w (z , a.lens, 0,32, r, 0,a.work, {bits: 5}), ta =! 1} a.lencode = q, a.lenbits = 9, a.distcode = r, a.distbits = 5} función l (a, b, c, d ) {var e, f = a.state; return null === f.window && (f.wsize = 1 << f.wbits, f.wnext = 0, f.whave = 0, f.window = new s. Buf8 (f.wsize)), d> = f.wsize? (S.arraySet (f.window, b, cf.wsize, f.wsize, 0), f.wnext = 0, f.whave = f.wsize ) :( e = f.wsize-f.wnext, e> d && (e = d), s.arraySet (f.window, b, cd, e, f.wnext), d- = e, d? (s .arraySet (f.window, b, cd, d, 0), f.wnext = d, f.whave = f.wsize) :( f.wnext + = e, f.wnext === f.wsize && (f. wnext = 0), f.whave <f.wsize && (f.whave + = e))), 0} función m (a, b) {var c, e, f, g, h, i, j, m, n , o, p, q, r, pa, qa, ra, sa, ta, ua, va, wa, xa, ya, za, Aa = 0, Ba = nuevo s.Buf8 (4), Ca = [16, 17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]; si (! A ||! A.state ||! a.output ||! a.input && 0! == a.avail_in) devuelve G; c = a.state, c.mode === W && (c.mode = X), h = a.next_out, f = a. salida, j = a.avail_out, g = a.next_in, e = a.input, i = a.avail_in, m = c.hold, n = c.bits, o = i, p = j, xa = D; a: for (;;) switch (c.mode) {case L: if (0 === c.wrap) {c.mode = X; break} para (; n <16;) {if (0 === i) break a; i -, m + = e [g ++] << n, n + = 8} if (2 & c.wrap && 35615 === m) {c.check = 0, Ba [0] = 255 & m, Ba [1] = m >>> 8 & 255, c.check = u (c.check , Ba, 2,0), m = 0, n = 0, c.mode = M; break} if (c.flags = 0, c.head && (c.head.done =! 1),! (1 & c. wrap) || (((255 & m) << 8) + (m >> 8))% 31) {a.msg = "verificación de encabezado incorrecta", c.mode = ma; break} if ((15 & m)! = = K) {a.msg = "método de compresión desconocido", c.mode = ma; break} if (m >>> = 4, n- = 4, wa = (15 & m) +8,0 === c. wbits) c.wbits = wa; si no (wa> c.wbits) {a.msg = "tamaño de ventana no válido", c.mode = ma; break} c.dmax = 1 << wa, a.adler = c .check = 1, c.mode = 512 & m? U: W, m = 0, n = 0; break; case M: for (; n <16;) {if (0 === i) break a; i- -, m + = e [g ++] << n, n + = 8} if (c.flags = m, (255 & c.flags)! == K) {a.msg = "método de compresión desconocido", c.mode = ma; break} if (57344 & c.flags) {a.msg = "conjunto de banderas de encabezado desconocido", c.mode = ma; break} c.head && (c.head.text = m >> 8 & 1), 512 & c.flags && (Ba [0] = 255 & m, Ba [1] = m >>> 8 & 255, c.check = u (c.check, Ba, 2,0)), m = 0, n = 0, c.mode = N; caso N: para (; n <32;) {if (0 === i) romper a; i -, m + = e [g ++] << n, n + = 8} c.head && (c.head.time = m), 512 & c.flags && (Ba [0] = 255 & m, Ba [1] = m >>> 8 y 255, Ba [ 2] = m >>> 16 y 255, Ba [3] = m >>> 24 y 255, c.check = u (c.check, Ba, 4,0)), m = 0, n = 0, c.mode = O; caso O: para (; n <16;) {if (0 === i) interrumpe a; i -, m + = e [g ++] << n, n + = 8} c.head && (c.head .xflags = 255 & m, c.head.os = m >> 8), 512 & c.flags && (Ba [0] = 255 & m, Ba [1] = m >>> 8 y 255, c.check = u (c.check, Ba , 2,0)), m = 0, n = 0, c.mode = P; caso P: if (1024 & c.flags) {for (; n <16;) {if (0 === i) break a; i -, m + = e [g ++] << n, n + = 8} c.length = m, c.head && (c.head.extra_len = m), 512 & c.flags && (Ba [0] = 255 & m, Ba [1] = m >>> 8 y 255, c.check = u (c.check, Ba, 2,0)), m = 0, n = 0} más c.head && (c.head.extra = null); c.mode = Q; case Q: if (1024 & c.flags && (q = c.length, q> i && (q = i ), q && (c.head && (wa = c.head.extra_len-c.length, c.head.extra || (c.head.extra = new Array (c.head.extra_len)), s.arraySet (c .head.extra, e, g, q, wa)), 512 & c. flags && (c.check = u (c.check, e, q, g)), i- = q, g + = q, c.length- = q), c.length)) break a; c.length = 0, c.mode = R; case R: if (2048 & c.flags) {if (0 === i) break a; q = 0; do wa = e [g + q ++], c.head && wa && c.length <65536 && (c.head.name + = String.fromCharCode (wa)); while (wa && q <i); if (512 & c.flags && (c.check = u ( c.check, e, q, g)), i- = q, g + = q,wa) break a} else c.head && (c.head.name = null); c.length = 0, c.mode = S; caso S: if (4096 & c.flags) {if (0 === i) break a; q = 0; do wa = e [g + q ++], c.head && wa && c.length <65536 && (c.head.comment + = String.fromCharCode (wa)); while (wa && q <i); if (512 & c.flags && (c.check = u (c.check, e, q, g)), i- = q, g + = q, wa) break a} else c.head && (c.head.comment = null); c.mode = T; caso T: if (512 & c.flags) {for (; n <16;) {if (0 === i) break a; i -, m + = e [g ++] << n, n + = 8 } if (m! == (65535 & c.check)) {a.msg = "incompatibilidad del encabezado crc", c.mode = ma; break} m = 0, n = 0} c.head && (c.head.hcrc = c.flags >> 9 & 1, c.head.done =! 0), a.adler = c.check = 0, c.mode = W; break; case U: for (; n <32;) {if (0 === i) romper a; i -, m + = e [g ++] << n, n + = 8} a.adler = c.check = d (m), m = 0, n = 0, c.mode = V; caso V: if (0 === c.havedict) devuelve a.next_out = h, a.avail_out = j, a.next_in = g, a.avail_in = i, c.hold = m, c.bits = n, F; a.adler = c.check = 1, c.mode = W; case W: if (b === B || b === C) interrumpe a; case X: if (c.last) {m >>> = 7 & n, n- = 7 & n, c.mode = ja; break} para (; n <3;) {if (0 === i) break a; i -, m + = e [g ++] << n, n + = 8} conmutador (c.last = 1 & m, m >>> = 1, n- = 1,3 & m) {caso 0: c.mode = Y; break ; caso 1: if (k (c), c.mode = ca, b === C) {m >>> = 2, n- = 2; break a} break; caso 2: c.mode = _; break; caso 3: a.msg = "tipo de bloque inválido", c.mode = ma} m >>> = 2, n- = 2; break; caso Y: for (m >>> = 7 & n, n- = 7 & n; n <32;) {if (0 === i) break a; i -, m + = e [g ++] << n, n + = 8} if ((65535 & m)! == (m >>> 16 ^ 65535)) {a.msg = "longitudes de bloque almacenadas no válidas", c.mode = ma; break} if (c.length = 65535 & m, m = 0, n = 0, c.mode = Z, b == = C) romper a; caso Z: c.mode = $; caso $: if (q = c.length) {if (q> i && (q = i), q> j && (q = j), 0 == = q) romper a; s.arraySet (f, e, g, q, h), i- = q, g + = q, j- = q, h + = q, c.length- = q;break} c.mode = W; break; case _: for (; n <14;) {if (0 === i) break a; i -, m + = e [g ++] << n, n + = 8 } if (c.nlen = (31 & m) + 257, m >>> = 5, n- = 5, c.ndist = (31 & m) + 1, m >>> = 5, n- = 5, c.ncode = (15 & m) + 4, m >>> = 4, n- = 4, c.nlen> 286 || c.ndist> 30) {a.msg = "demasiados símbolos de longitud o distancia", c.mode = ma; break} c.have = 0, c.mode = aa; case aa: for (; c.have <c.ncode;) {for (; n <3;) {if (0 === i) break a; i -, m + = e [g ++] << n, n + = 8} c.lens [Ca [c.have ++]] = 7 & m, m >>> = 3, n- = 3} para (; c .have <19;) c.lens [Ca [c.have ++]] = 0; if (c.lencode = c.lendyn, c.lenbits = 7, ya = {bits: c.lenbits}, xa = w ( x, c.lens, 0,19, c.lencode, 0, c.work, ya), c.lenbits = ya.bits, xa) {a.msg = "conjunto de longitudes de código no válidas", c.mode = ma ; break} c.have = 0, c.mode = ba; case ba: for (; c.have <c.nlen + c.ndist;) {for (; Aa = c.lencode [m & (1 << c .lenbits) -1], qa = Aa >>> 24, ra = Aa >>> 16 y 255,sa = 65535 & Aa,! (qa <= n);) {if (0 === i) se rompe a; i -, m + = e [g ++] << n, n + = 8} if (sa <16) m >>> = qa, n- = qa, c.lens [c.have ++] = sa; else {if (16 === sa) {for (za = qa + 2; n <za;) {if (0 === i) romper a; i -, m + = e [g ++] << n, n + = 8} if (m >>> = qa, n- = qa, 0 === c.have) {a .msg = "repetición de longitud de bit no válida", c.mode = ma; break} wa = c.lens [c.have-1], q = 3 + (3 & m), m >>> = 2, n- = 2 } else if (17 === sa) {for (za = qa + 3; n <za;) {if (0 === i) break a; i -, m + = e [g ++] << n, n + = 8} m >>> = qa, n- = qa, wa = 0, q = 3 + (7 & m), m >>> = 3, n- = 3} else {for (za = qa + 7; n <za;) {if (0 === i) interrumpe a; i -, m + = e [g ++] << n, n + = 8} m >>> = qa, n- = qa, wa = 0 , q = 11 + (127 & m), m >>> = 7, n- = 7} if (c.have + q> c.nlen + c.ndist) {a.msg = "repetición de longitud de bit no válida", c .mode = ma; break} para (; q -;) c.lens [c.have ++] = wa}} if (c.mode === ma) break; if (0 === c.lens [256 ]) {a.msg = "código no válido: falta el final del bloque ", c.mode = ma; break} if (c.lenbits = 9, ya = {bits: c.lenbits}, xa = w (y, c.lens, 0, c.nlen, c.lencode, 0, c.work, ya), c.lenbits = ya.bits, xa) {a.msg = "conjunto de longitudes / literales no válidos", c.mode = ma; break} if ( c.distbits = 6, c.distcode = c.distdyn, ya = {bits: c.distbits}, xa = w (z, c.lens, c.nlen, c.ndist, c.distcode, 0, c. trabajo, ya), c.distbits = ya.bits, xa) {a.msg = "conjunto de distancias no válidas", c.mode = ma; break} if (c.mode = ca, b === C) break a ; caso ca: c.mode = da; caso da: if (i> = 6 && j> = 258) {a.next_out = h, a.avail_out = j, a.next_in = g, a.avail_in = i, c. hold = m, c.bits = n, v (a, p), h = a.next_out, f = a.output, j = a.avail_out, g = a.next_in, e = a.input, i = a .avail_in, m = c.hold, n = c.bits, c.mode === W && (c.back = -1); break} for (c.back = 0; Aa = c.lencode [m & (1 << c.lenbits) -1], qa = Aa >>> 24, ra = Aa >>> 16 y 255, sa = 65535 y Aa,! (qa <= n);) {if (0 === i) rompa un ;yo--,m + = e [g ++] << n, n + = 8} if (ra && 0 === (240 & ra)) {for (ta = qa, ua = ra, va = sa; Aa = c.lencode [va + ((m & ( 1 << ta + ua) -1) >> ta)], qa = Aa >>> 24, ra = Aa >>> 16 y 255, sa = 65535 y Aa,! (Ta + qa <= n);) {if ( 0 === i) romper a; i -, m + = e [g ++] << n, n + = 8} m >>> = ta, n- = ta, c.back + = ta} if (m >> > = qa, n- = qa, c.back + = qa, c.length = sa, 0 === ra) {c.mode = ia; break} if (32 & ra) {c.back = -1, c. mode = W; break} if (64 & ra) {a.msg = "código de longitud / literal no válido", c.mode = ma; break} c.extra = 15 & ra, c.mode = ea; caso ea: if (c. extra) {for (za = c.extra; n <za;) {if (0 === i) break a; i -, m + = e [g ++] << n, n + = 8} c.length + = m & (1 << c.extra) -1, m >>> = c.extra, n- = c.extra, c.back + = c.extra} c.was = c.length, c.mode = fa; caso fa: for (; Aa = c.distcode [m & (1 << c.distbits) -1], qa = Aa >>> 24, ra = Aa >>> 16 & 255, sa = 65535 & Aa,! (qa <= norte);) {if (0 === i) romper a; i -, m + = e [g ++] << n, n + = 8} if (0 === (240 & ra)) {for (ta = qa, ua = ra, va = sa; Aa = c. código de referencia [va + ((m & (1 << ta + ua) -1) >> ta)], qa = Aa >>> 24, ra = Aa >>> 16 y 255, sa = 65535 & Aa,! (Ta + qa <= n);) {if (0 === i) se rompe a; i -, m + = e [g ++] << n, n + = 8} m >>> = ta , n- = ta, c.back + = ta} if (m >>> = qa, n- = qa, c.back + = qa, 64 & ra) {a.msg = "código de distancia no válido", c.mode = ma ; break} c.offset = sa, c.extra = 15 & ra, c.mode = ga; case ga: if (c.extra) {for (za = c.extra; n <za;) {if (0 == = i) romper a; i -, m + = e [g ++] << n, n + = 8} c.offset + = m & (1 << c.extra) -1, m >>> = c.extra, n - = c.extra, c.back + = c.extra} if (c.offset> c.dmax) {a.msg = "distancia inválida demasiado atrás", c.mode = ma; break} c.mode = ha ; caso ha: if (0 === j) break a; if (q = pj, c.offset> q) {if (q = c.offset-q, q> c.whave && c.sane) {a.msg = "distancia inválida demasiado atrás ", c.mode = ma; break} q> c.wnext? (q- = c.wnext, r = c.wsize-q): r = c.wnext-q, q> c. longitud && (q = c.length), pa = c.window} else pa = f, r = hc.offset, q = c.length; q> j && (q = j), j- = q, c.length- = q; do f [h ++] = pa [r ++]; while (- q); 0 === c.length && (c.mode = da); break; case ia: if (0 === j) break a; f [h ++] = c.length, j -, c.mode = da; break; case ja: if (c.wrap) {for (; n <32;) {if (0 === i) divida a; i -, m | = e [g ++] << n, n + = 8} if (p- = j, a.total_out + = p, c.total + = p, p && (a.adler = c.check = c.flags? u (c.check, f, p, hp): t (c.check, f, p, hp)), p = j, (c.flags? m: d (m))! = = c.check) {a.msg = "verificación de datos incorrecta", c.mode = ma; break} m = 0, n = 0} c.mode = ka; case ka: if (c.wrap && c.flags) { for (; n <32;) {if (0 === i) break a; i -, m + = e [g ++] << n, n + = 8} if (m! == (4294967295 & c.total)) {a.msg = "verificación de longitud incorrecta", c.mode = ma; break} m = 0, n = 0} c.mode = la; case la:xa = E; break a; case ma: xa = H; break a; case na: return I; case oa: default: return G} return a.next_out = h, a.avail_out = j, a.next_in = g, a.avail_in = i, c.hold = m, c.bits = n, (c.wsize || p! == a.avail_out && c.mode <ma && (c.mode <ja || b! == A)) && l (a, a.output, a.next_out, pa.avail_out)? (c.mode = na, I) :( o- = a.avail_in, p- = a.avail_out, a.total_in + = o, a. total_out + = p, c.total + = p, c.wrap && p && (a.adler = c.check = c.flags? u (c.check, f, p, a.next_out-p): t (c.check, f , p, a.next_out-p)), a.data_type = c.bits + (c.last? 64: 0) + (c.mode === W? 128: 0) + (c.mode === ca || c.mode === Z? 256: 0), (0 === o && 0 === p || b === A) && xa === D && (xa = J), xa)} función n ( a) {if (! a ||! a.state) devuelve G; var b = a.state; devuelve b.window && (b.window = null), a.state = null, D} función o (a, b ) {var c; devuelve un && a.state? (c = a.state, 0 === (2 & c.wrap)? G: (c.head = b, b.done =! 1, D)): función G} Pensilvania,b) {var c, d, e, f = b.length; devuelve un && a.state? (c = a.state, 0! == c.wrap && c.mode! == V? G: c.mode === V && (d = 1, d = t (d, b, f, 0), d! == c.check)? H: (e = l (a, b, f, f))? (C.mode = na, I) :( c.havedict = 1, D)): G} ​​var q, r, s = a ("../ utils / common"), t = a ("./ adler32"), u = a ("./ crc32"), v = a ("./ inffast"), w = a ("./ inftrees"), x = 0, y = 1, z = 2, A = 4, B = 5 , C = 6, D = 0, E = 1, F = 2, G = -2, H = -3, I = -4, J = -5, K = 8, L = 1, M = 2, N = 3, O = 4, P = 5, Q = 6, R = 7, S = 8, T = 9, U = 10, V = 11, W = 12, X = 13, Y = 14, Z = 15 , $ = 16, _ = 17, aa = 18, ba = 19, ca = 20, da = 21, ea = 22, fa = 23, ga = 24, ha = 25, ia = 26, ja = 27, ka = 28, la = 29, ma = 30, na = 31, oa = 32, pa = 852, qa = 592, ra = 15, sa = ra, ta =! 0; c.inflateReset = g, c.inflateReset2 = h, c.inflateResetKeep = f, c.inflateInit = j, c.inflateInit2 = i, c.inflate = m, c.inflateEnd = n, c.inflateGetHeader = o, c.inflateSetDictionary = p, c.inflateInfo = "pako inflar (del proyecto Nodeca) "}, {" ../ utils / common ": 62,"./adler32":64,"./crc32":66,"./inffast":69,"./inftrees":71}font>,71:[function(a,b,c){"use estricto" ; var d = a ("../ utils / common"), e = 15, f = 852, g = 592, h = 0, i = 1, j = 2, k = [3,4,5,6 , 7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0], l = [16,16 , 16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21 , 21,16,72,78], m = [1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097 , 6145,8193,12289,16385,24577,0,0], n = [16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22 , 23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64]; b.exports = function (a, b, c, o, p, q, r, s) {var t, u, v, w, x, y, z, A, B, C = bits de bits, D = 0, E = 0, F = 0, G = 0, H = 0, I = 0, J = 0, K = 0, L = 0, M = 0, N = nulo, O = 0, P = nuevo d.Buf16 (e + 1), Q = nuevo d.Buf16 (e +1), R = nulo, S = 0; para (D = 0; D <= e; D ++) P [D] = 0; para (E = 0; E <o; E ++) P [b [c + E]] ++; para (H = C, G = e;G> = 1 && 0 === P [G]; G -); if (H> G && (H = G), 0 === G) devuelve p [q ​​++] = 20971520, p [q ​​++] = 20971520, s .bits = 1,0; para (F = 1; F <G && 0 === P [F]; F ++); para (H <F && (H = F), K = 1, D = 1; D <= e ; D ++) if (K << = 1, K- = P [D], K <0) return-1; if (K> 0 && (a === h || 1! == G)) return-1 ; para (Q [1] = 0, D = 1; D <e; D ++) Q [D + 1] = Q [D] + P [D]; para (E = 0; E <o; E ++) 0 ! == b [c + E] && (r [Q [b [c + E]] ++] = E); if (a === h? (N = R = r, y = 19): a === i? (N = k, O- = 257, R = l, S- = 257, y = 256) :( N = m, R = n, y = -1), M = 0, E = 0, D = F, x = q, I = H, J = 0, v = -1, L = 1 << H, w = L-1, a === i && L> f || a === j && L > g) devuelve 1; para (var T = 0 ;;) {T ++, z = DJ, r [E] <y? (A = 0, B = r [E]): r [E]> y? ( A = R [S + r [E]], B = N [O + r [E]]) :( A = 96, B = 0), t = 1 << DJ, u = 1 << I, F = u; do u- = t, p [x + (M >> J) + u] = z << 24 | A << 16 | B | 0; while (0! == u); para (t = 1 << D-1; M & t;) t >> = 1; if (0! == t? (M & = t-1, M + = t): M = 0, E ++, 0 === - P [D ]) {if (D === G) break;D = b [c + r [E]]} if (D> H && (M & w)! == v) {for (0 === J && (J = H), x + = F, I = DJ, K = 1 << I; I + J <G && (K- = P [I + J],! (K <= 0));) I ++, K << = 1; if (L + = 1 << I, a == = i && L> f || a === j && L> g) return 1; v = M & w, p [v] = H << 24 | I << 16 | xq | 0}} return 0! == M && (p [ x + M] = DJ << 24 | 64 << 16 | 0), s.bits = H, 0}}, {"../ utils / common": 62}], 72: [función (a, b , c) {"use estricto"; b.exports = {2: "necesita diccionario", 1: "fin de secuencia", 0: "", "- 1": "error de archivo", "- 2": "secuencia error "," - 3 ":" error de datos "," - 4 ":" memoria insuficiente "," - 5 ":" error de búfer "," - 6 ":" versión incompatible "}}, {}], 73 : [función (a, b, c) {"usar estricto"; función d (a) {para (var b = a.length; - b> = 0;) a [b] = 0} función e (a, b, c, d, e) {this.static_tree = a, this.extra_bits = b, this.extra_base = c, this.elems = d, this.max_length = e, this.has_stree = a && a.length} función f (a, b) {this.dyn_tree = a, this.max_code = 0, this.stat_desc = b} función g (a) {return a <256? ia [a ]: ia [256+ (a >>> 7)]} función h (a, b) {a.pending_buf [a.pending ++] = 255 & b, a.pending_buf [a.pending ++] = b >>> 8 y 255} función i (a, b, c) {a.bi_valid> Xc? (a.bi_buf | = b << a.bi_valid & 65535, h (a, a.bi_buf), a.bi_buf = b >> Xa.bi_valid, a. bi_valid + = cX) :( a.bi_buf | = b << a.bi_valid & 65535, a.bi_valid + = c)} función j (a, b, c) {i (a, c [2 * b], c [2 * b + 1])} función k (a, b) {var c = 0; do c | = 1 & a, a >>> = 1, c << = 1; while (- b> 0); return c> >> 1} función l (a) {16 === a.bi_valid? (H (a, a.bi_buf), a.bi_buf = 0, a.bi_valid = 0): a.bi_valid> = 8 && (a. pendiente_buf [a.pending ++] = 255 & a.bi_buf,a.bi_buf >> = 8, a.bi_valid- = 8)} función m (a, b) {var c, d, e, f, g, h, i = b.dyn_tree, j = b.max_code, k = b.stat_desc.static_tree, l = b.stat_desc.has_stree, m = b.stat_desc.extra_bits, n = b.stat_desc.extra_base, o = b.stat_desc.max_length, p = 0; para (f = 0; f <= W; f ++) a.bl_count [f] = 0; para (i [2 * a.heap [a.heap_max] +1] = 0, c = a.heap_max + 1; c <V; c ++) d = a.heap [c], f = i [2 * i [2 * d + 1] +1] + 1, f> o && (f = o, p ++), i [2 * d + 1] = f, d> j || (a.bl_count [f] ++, g = 0, d> = n && (g = m [dn]), h = i [2 * d], a.opt_len + = h * (f + g), l && (a.static_len + = h * (k [2 * d + 1] + g))); if (0! == p) {do {for (f = o-1; 0 === a .bl_count [f];) f -; a.bl_count [f] -, a.bl_count [f + 1] + = 2, a.bl_count [o] -, p- = 2} while (p> 0); para (f = o; 0! == f; f -) para (d = a.bl_count [f]; 0! == d;) e = a.heap [- c], e> j || (i [2 * e + 1]! == f && (a.opt_len + = (fi [2 * e + 1]) * i [2 * e], i [2 * e + 1] = f) , d -)}} función n (a, b, c) {var d, e, f = nueva matriz (W + 1), g = 0;bi_valid- = 8)} función m (a, b) {var c, d, e, f, g, h, i = b.dyn_tree, j = b.max_code, k = b.stat_desc.static_tree, l = b .stat_desc.has_stree, m = b.stat_desc.extra_bits, n = b.stat_desc.extra_base, o = b.stat_desc.max_length, p = 0; for (f = 0; f <= W; f ++) a.bl_count [ f] = 0; para (i [2 * a.heap [a.heap_max] +1] = 0, c = a.heap_max + 1; c <V; c ++) d = a.heap [c], f = i [2 * i [2 * d + 1] +1] + 1, f> o && (f = o, p ++), i [2 * d + 1] = f, d> j || (a.bl_count [ f] ++, g = 0, d> = n && (g = m [dn]), h = i [2 * d], a.opt_len + = h * (f + g), l && (a.static_len + = h * (k [2 * d + 1] + g))); if (0! == p) {do {for (f = o-1; 0 === a.bl_count [f];) f-- ; a.bl_count [f] -, a.bl_count [f + 1] + = 2, a.bl_count [o] -, p- = 2} while (p> 0); for (f = o; 0 ! == f; f -) para (d = a.bl_count [f]; 0! == d;) e = a.heap [- c], e> j || (i [2 * e + 1]! == f && (a.opt_len + = (fi [2 * e + 1]) * i [2 * e], i [2 * e + 1] = f), d -)}} función n ( a, b, c) {var d, e, f = nueva matriz (W + 1), g = 0;bi_valid- = 8)} función m (a, b) {var c, d, e, f, g, h, i = b.dyn_tree, j = b.max_code, k = b.stat_desc.static_tree, l = b .stat_desc.has_stree, m = b.stat_desc.extra_bits, n = b.stat_desc.extra_base, o = b.stat_desc.max_length, p = 0; for (f = 0; f <= W; f ++) a.bl_count [ f] = 0; para (i [2 * a.heap [a.heap_max] +1] = 0, c = a.heap_max + 1; c <V; c ++) d = a.heap [c], f = i [2 * i [2 * d + 1] +1] + 1, f> o && (f = o, p ++), i [2 * d + 1] = f, d> j || (a.bl_count [ f] ++, g = 0, d> = n && (g = m [dn]), h = i [2 * d], a.opt_len + = h * (f + g), l && (a.static_len + = h * (k [2 * d + 1] + g))); if (0! == p) {do {for (f = o-1; 0 === a.bl_count [f];) f-- ; a.bl_count [f] -, a.bl_count [f + 1] + = 2, a.bl_count [o] -, p- = 2} while (p> 0); for (f = o; 0 ! == f; f -) para (d = a.bl_count [f]; 0! == d;) e = a.heap [- c], e> j || (i [2 * e + 1]! == f && (a.opt_len + = (fi [2 * e + 1]) * i [2 * e], i [2 * e + 1] = f), d -)}} función n ( a, b, c) {var d, e, f = nueva matriz (W + 1), g = 0;static_tree, l = b.stat_desc.has_stree, m = b.stat_desc.extra_bits, n = b.stat_desc.extra_base, o = b.stat_desc.max_length, p = 0; for (f = 0; f <= W; f ++ ) a.bl_count [f] = 0; for (i [2 * a.heap [a.heap_max] +1] = 0, c = a.heap_max + 1; c <V; c ++) d = a.heap [ c], f = i [2 * i [2 * d + 1] +1] + 1, f> o && (f = o, p ++), i [2 * d + 1] = f, d> j || (a.bl_count [f] ++, g = 0, d> = n && (g = m [dn]), h = i [2 * d], a.opt_len + = h * (f + g), l && ( a.static_len + = h * (k [2 * d + 1] + g))); if (0! == p) {do {for (f = o-1; 0 === a.bl_count [f] ;) f -; a.bl_count [f] -, a.bl_count [f + 1] + = 2, a.bl_count [o] -, p- = 2} while (p> 0); para ( f = o; 0! == f; f -) para (d = a.bl_count [f]; 0! == d;) e = a.heap [- c], e> j || (i [2 * e + 1]! == f && (a.opt_len + = (fi [2 * e + 1]) * i [2 * e], i [2 * e + 1] = f), d--) }} función n (a, b, c) {var d, e, f = nueva matriz (W + 1), g = 0;static_tree, l = b.stat_desc.has_stree, m = b.stat_desc.extra_bits, n = b.stat_desc.extra_base, o = b.stat_desc.max_length, p = 0; for (f = 0; f <= W; f ++ ) a.bl_count [f] = 0; for (i [2 * a.heap [a.heap_max] +1] = 0, c = a.heap_max + 1; c <V; c ++) d = a.heap [ c], f = i [2 * i [2 * d + 1] +1] + 1, f> o && (f = o, p ++), i [2 * d + 1] = f, d> j || (a.bl_count [f] ++, g = 0, d> = n && (g = m [dn]), h = i [2 * d], a.opt_len + = h * (f + g), l && ( a.static_len + = h * (k [2 * d + 1] + g))); if (0! == p) {do {for (f = o-1; 0 === a.bl_count [f] ;) f -; a.bl_count [f] -, a.bl_count [f + 1] + = 2, a.bl_count [o] -, p- = 2} while (p> 0); para ( f = o; 0! == f; f -) para (d = a.bl_count [f]; 0! == d;) e = a.heap [- c], e> j || (i [2 * e + 1]! == f && (a.opt_len + = (fi [2 * e + 1]) * i [2 * e], i [2 * e + 1] = f), d--) }} función n (a, b, c) {var d, e, f = nueva matriz (W + 1), g = 0;para (i [2 * a.heap [a.heap_max] +1] = 0, c = a.heap_max + 1; c <V; c ++) d = a.heap [c], f = i [2 * i [2 * d + 1] +1] + 1, f> o && (f = o, p ++), i [2 * d + 1] = f, d> j || (a.bl_count [f] ++, g = 0, d> = n && (g = m [dn]), h = i [2 * d], a.opt_len + = h * (f + g), l && (a.static_len + = h * (k [2 * d + 1] + g))); if (0! == p) {do {for (f = o-1; 0 === a.bl_count [f];) f -; a.bl_count [ f] -, a.bl_count [f + 1] + = 2, a.bl_count [o] -, p- = 2} while (p> 0); for (f = o; 0! == f; f -) para (d = a.bl_count [f]; 0! == d;) e = a.heap [- c], e> j || (i [2 * e + 1]! == f && (a.opt_len + = (fi [2 * e + 1]) * i [2 * e], i [2 * e + 1] = f), d -)}} función n (a, b, c ) {var d, e, f = nueva matriz (W + 1), g = 0;para (i [2 * a.heap [a.heap_max] +1] = 0, c = a.heap_max + 1; c <V; c ++) d = a.heap [c], f = i [2 * i [2 * d + 1] +1] + 1, f> o && (f = o, p ++), i [2 * d + 1] = f, d> j || (a.bl_count [f] ++, g = 0, d> = n && (g = m [dn]), h = i [2 * d], a.opt_len + = h * (f + g), l && (a.static_len + = h * (k [2 * d + 1] + g))); if (0! == p) {do {for (f = o-1; 0 === a.bl_count [f];) f -; a.bl_count [ f] -, a.bl_count [f + 1] + = 2, a.bl_count [o] -, p- = 2} while (p> 0); for (f = o; 0! == f; f -) para (d = a.bl_count [f]; 0! == d;) e = a.heap [- c], e> j || (i [2 * e + 1]! == f && (a.opt_len + = (fi [2 * e + 1]) * i [2 * e], i [2 * e + 1] = f), d -)}} función n (a, b, c ) {var d, e, f = nueva matriz (W + 1), g = 0;bl_count [f] -, a.bl_count [f + 1] + = 2, a.bl_count [o] -, p- = 2} while (p> 0); for (f = o; 0! == f; f -) para (d = a.bl_count [f]; 0! == d;) e = a.heap [- c], e> j || (i [2 * e + 1]! == f && (a.opt_len + = (fi [2 * e + 1]) * i [2 * e], i [2 * e + 1] = f), d -)}} función n (a, b , c) {var d, e, f = nueva matriz (W + 1), g = 0;bl_count [f] -, a.bl_count [f + 1] + = 2, a.bl_count [o] -, p- = 2} while (p> 0); for (f = o; 0! == f; f -) para (d = a.bl_count [f]; 0! == d;) e = a.heap [- c], e> j || (i [2 * e + 1]! == f && (a.opt_len + = (fi [2 * e + 1]) * i [2 * e], i [2 * e + 1] = f), d -)}} función n (a, b , c) {var d, e, f = nueva matriz (W + 1), g = 0;
    para (d = 1; d <= W; d ++) f [d] = g = g + c [d-1] << 1; para (e = 0; e <= b; e ++) {var h = a [2 * e + 1]; 0! == h && (a [2 * e] = k (f [h] ++, h))}} función o () {var a, b, c, d, f , g = nueva matriz (W + 1); para (c = 0, d = 0; d <Q-1; d ++) para (ka [d] = c, a = 0; a <1 << ba [d ]; a ++) ja [c ++] = d; para (ja [c-1] = d, f = 0, d = 0; d <16; d ++) para (la [d] = f, a = 0; a <1 << ca [d]; a ++) ia [f ++] = d; para (f >> = 7; d <T; d ++) para (la [d] = f << 7, a = 0; a < 1 << ca [d] -7; a ++) ia [256 + f ++] = d; para (b = 0; b <= W; b ++) g [b] = 0; para (a = 0; a <= 143;) ga [2 * a + 1] = 8, a ++, g [8] ++; para (; a <= 255;) ga [2 * a + 1] = 9, a ++, g [9] + +; para (; a <= 279;) ga [2 * a + 1] = 7, a ++, g [7] ++; para (; a <= 287;) ga [2 * a + 1] = 8 , a ++, g [8] ++; para (n (ga, S + 1, g), a = 0; a <T; a ++) ha [2 * a + 1] = 5, ha [2 * a] = k (a, 5); ma = nueva e (ga, ba, R + 1, S, W), na = nueva e (ha, ca, 0, T, W), oa = nueva e (nueva matriz ( 0), da, 0, U, Y)} función p (a) {var b; para (b = 0; b <S; b ++) a.dyn_ltree [2 * b] = 0; para (b = 0; b <T; b ++) a.dyn_dtree [2 * b] = 0; para (b = 0; b <U; b ++) a.bl_tree [2 * b] = 0; a.dyn_ltree [2 * Z] = 1, a.opt_len = a.static_len = 0, a.last_lit = a.matches = 0} función q (a) {a.bi_valid> 8? H (a, a.bi_buf): a.bi_valid> 0 && (a.pending_buf [a.pending ++] = a.bi_buf), a.bi_buf = 0, a.bi_valid = 0} función r (a, b, c, d) {q (a), d && (h (a, c), h (a, ~ c)), G.arraySet (a.pending_buf, a.window, b, c, a.pending), a .pending + = c} función s (a, b, c, d) {var e = 2 * b, f = 2 * c; devuelve a [e] <a [f] || a [e] === a [f] && d [b] <= d [c]} función t (a, b, c) {for (var d = a.heap [c], e = c << 1; e <= a.heap_len && ( e <a.heap_len && s (b, a.heap [e + 1], a.heap [e], a.depth) && e ++ ,! s (b, d, a.heap [e], a.depth)); ) a.heap [c] = a.heap [e], c = e, e << = 1; a.heap [c] = d} función u (a, b, c) {var d, e, f , h, k = 0; if (0! == a.last_lit) do d = a.pending_buf [a.d_buf + 2 * k] << 8 | a.pending_buf [a.d_buf + 2 * k + 1] , e = a.pending_buf [a.l_buf + k], k ++, 0 === d? j (a, e, b) :( f = ja [e], j (a, f + R + 1, b ), h = ba [f], 0! == h &&(e- = ka [f], i (a, e, h)), d -, f = g (d), j (a, f, c), h = ca [f], 0! == h && (d- = la [f], i (a, d, h))); while (k <a.last_lit); j (a, Z, b)} función v (a, b) {var c, d, e, f = b.dyn_tree, g = b.stat_desc.static_tree, h = b.stat_desc.has_stree, i = b.stat_desc.elems, j = -1; for (a.heap_len = 0, a.heap_max = V, c = 0; c <i; c ++) 0! == f [2 * c]? (A.heap [++ a.heap_len] = j = c, a.depth [c] = 0): f [2 * c + 1] = 0; para (; a.heap_len <2;) e = a.heap [++ a.heap_len] = j <2? ++ j: 0, f [2 * e] = 1, a profundidad [e] = 0, a.opt_len -, h && (a.static_len- = g [2 * e + 1]); para (b.max_code = j, c = a.heap_len >> 1; c> = 1; c -) t (a, f, c); e = i; do c = a.heap [1], a.heap [1] = a.heap [a.heap_len-- ], t (a, f, 1), d = a.heap [1], a.heap [- a.heap_max] = c, a.heap [- a.heap_max] = d, f [2 * e] = f [2 * c] + f [2 * d], a.depth [e] = (a.depth [c]> = a.depth [d]? a.depth [c]: a.depth [d]) + 1, f [2 * c + 1] = f [2 * d + 1] = e, a.heap [1] = e ++, t (a, f, 1); while (a.heap_len > = 2); a.heap [- a.heap_max] = a.heap [1], m (a, b), n (f, j, a.bl_count)} función w (a, b, c) {var d, e, f = -1, g = b [1], h = 0, i = 7, j = 4; para (0 === g && ( i = 138, j = 3), b [2 * (c + 1) +1] = 65535, d = 0; d <= c; d ++) e = g, g = b [2 * (d + 1) +1], ++ h <i && e === g || (h <j? A.bl_tree [2 * e] + = h: 0! == e? (E! == f && a.bl_tree [2 * e ] ++, a.bl_tree [2 * $] ++): h <= 10? a.bl_tree [2 * _] ++: a.bl_tree [2 * aa] ++, h = 0, f = e , 0 === g? (I = 138, j = 3): e === g? (I = 6, j = 3) :( i = 7, j = 4))} función x (a, b , c) {var d, e, f = -1, g = b [1], h = 0, k = 7, l = 4; para (0 === g && (k = 138, l = 3), d = 0; d <= c; d ++) if (e = g, g = b [2 * (d + 1) +1],! (++ h <k && e === g)) {if (h < l) {do j (a, e, a.bl_tree); while (0! == - h)} else 0! == e? (e! == f && (j (a, e, a.bl_tree) , h -), j (a, $, a.bl_tree), i (a, h-3,2)): h <= 10? (j (a, _, a.bl_tree), i (a, h-3,3)) :( j (a, aa, a.bl_tree), i (a, h-11,7)); h = 0, f = e, 0 === g? (k = 138 , l = 3): e === g? (k = 6, l = 3) :( k = 7, l = 4)}} función y (a) {var b; para (w (a, a. dyn_ltree, a.l_desc.max_code), w (a, a.dyn_dtree, a.d_desc.max_code), v (a, a.bl_desc),b = U-1; b> = 3 && 0 === a.bl_tree [2 * ea [b] +1]; b -); devuelve a.opt_len + = 3 * (b + 1) + 5 + 5 + 4 , b} función z (a, b, c, d) {var e; para (i (a, b-257,5), i (a, c-1,5), i (a, d-4, 4), e = 0; e <d; e ++) i (a, a.bl_tree [2 * ea [e] +1], 3); x (a, a.dyn_ltree, b-1), x (a , a.dyn_dtree, c-1)} función A (a) {var b, c = 4093624447; para (b = 0; b <= 31; b ++, c >>> = 1) if (1 & c && 0! == a .dyn_ltree [2 * b]) devuelve I; if (0! == a.dyn_ltree [18] || 0! == a.dyn_ltree [20] || 0! == a.dyn_ltree [26]) devuelve J ; for (b = 32; b <R; b ++) if (0! == a.dyn_ltree [2 * b]) devuelve J; devuelve I} función B (a) {pa || (o (), pa = ! 0), a.l_desc = new f (a.dyn_ltree, ma), a.d_desc = new f (a.dyn_dtree, na), a.bl_desc = new f (a.bl_tree, oa), a.bi_buf = 0, a.bi_valid = 0, p (a)} función C (a, b, c, d) {i (a, (L << 1) + (d? 1: 0), 3), r (a , b, c,! 0)} función D (a) {i (a, M << 1,3), j (a, Z, ga), l (a)} función E (a, b, c, d) {var e, f, g = 0; a.level> 0? (a.strm.data_type === K && (a.strm.data_type = A (a)), v (a, a.l_desc), v (a, a.d_desc), g = y (a), e = a.opt_len + 3 + 7 >>> 3, f = a.static_len + 3 + 7 >>> 3, f <= e && (e = f)): e = f = c + 5, c + 4 <= e && b! == - 1? C (a, b, c, d): a.strategy === H || f = == e? (i (a, (M << 1) + (d? 1: 0), 3), u (a, ga, ha)) :( i (a, (N << 1) + ( d? 1: 0), 3), z (a, a.l_desc.max_code + 1, a.d_desc.max_code + 1, g + 1), u (a, a.dyn_ltree, a.dyn_dtree)), p (a), d && q (a)} función F (a, b, c) {return a.pending_buf [a.d_buf + 2 * a.last_lit] = b >>> 8 & 255, a.pending_buf [a.d_buf + 2 * a.last_lit + 1] = 255 & b, a.pending_buf [a.l_buf + a.last_lit] = 255 & c, a.last_lit ++, 0 === b? a.dyn_ltree [2 * c] ++ :( a.matches ++ , b -, a.dyn_ltree [2 * (ja [c] + R + 1)] ++, a.dyn_dtree [2 * g (b)] ++), a.last_lit === a.lit_bufsize- 1} var G = a ("../ utils / common"), H = 4, I = 0, J = 1, K = 2, L = 0, M = 1, N = 2, O = 3, P = 258, Q = 29, R = 256, S = R + 1 + Q, T = 30, U = 19, V = 2 * S + 1, W = 15, X = 16, Y = 7, Z = 256 , $ = 16, _ = 17, aa = 18, ba = [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3, 3,3,3,4,4,4,4,5,5,5,5,0], ca = [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6, 7,7,8,8,9,9,10,10,11,11,12,12,13,13], da = [0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,2,3,7], ea = [16,17,18,0,8,7,9,6,10,5,11,4,12, 3,13,2,14,1,15], fa = 512, ga = nueva matriz (2 * (S + 2)); d (ga); var ha = nueva matriz (2 * T); d (ha ); var ia = nueva matriz (fa); d (ia); var ja = nueva matriz (P-O + 1); d (ja); var ka = nueva matriz (Q); d (ka); var la = nueva matriz (T); d (la); var ma, na, oa, pa =! 1; c._tr_init = B, c._tr_stored_block = C, c._tr_flush_block = E, c._tr_tally = F, c. _tr_align = D}, {"../ utils / common": 62}], 74: [función (a, b, c) {"uso estricto"; función d () {this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = nulo, this.data_type = 2, this.adler = 0} b.exports = d}, {}]}, {}, [10]) (10)});13,13], da = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7], ea = [ 16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15], fa = 512, ga = nueva matriz (2 * (S + 2)); d (ga); var ha = nueva matriz (2 * T); d (ha); var ia = nueva matriz (fa); d (ia); var ja = nueva matriz (P- O + 1); d (ja); var ka = nueva matriz (Q); d (ka); var la = nueva matriz (T); d (la); var ma, na, oa, pa =! 1; c._tr_init = B, c._tr_stored_block = C, c._tr_flush_block = E, c._tr_tally = F, c._tr_align = D}, {"../ utils / common": 62}], 74: [función ( a, b, c) {"use estricto"; función d () {this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0} b.exports = d}, {}] }, {}, [10]) (10)});13,13], da = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7], ea = [ 16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15], fa = 512, ga = nueva matriz (2 * (S + 2)); d (ga); var ha = nueva matriz (2 * T); d (ha); var ia = nueva matriz (fa); d (ia); var ja = nueva matriz (P- O + 1); d (ja); var ka = nueva matriz (Q); d (ka); var la = nueva matriz (T); d (la); var ma, na, oa, pa =! 1; c._tr_init = B, c._tr_stored_block = C, c._tr_flush_block = E, c._tr_tally = F, c._tr_align = D}, {"../ utils / common": 62}], 74: [función ( a, b, c) {"use estricto"; función d () {this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0} b.exports = d}, {}] }, {}, [10]) (10)});var ia = nueva matriz (fa); d (ia); var ja = nueva matriz (P-O + 1); d (ja); var ka = nueva matriz (Q); d (ka); var la = nueva Matriz (T); d (la); var ma, na, oa, pa =! 1; c._tr_init = B, c._tr_stored_block = C, c._tr_flush_block = E, c._tr_tally = F, c._tr_align = D}, {"../ utils / common": 62}], 74: [función (a, b, c) {"usar estricto"; función d () {this.input = null, this.next_in = 0 , this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0} b.exports = d}, {}]}, {}, [10]) (10)});var ia = nueva matriz (fa); d (ia); var ja = nueva matriz (P-O + 1); d (ja); var ka = nueva matriz (Q); d (ka); var la = nueva Matriz (T); d (la); var ma, na, oa, pa =! 1; c._tr_init = B, c._tr_stored_block = C, c._tr_flush_block = E, c._tr_tally = F, c._tr_align = D}, {"../ utils / common": 62}], 74: [función (a, b, c) {"usar estricto"; función d () {this.input = null, this.next_in = 0 , this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0} b.exports = d}, {}]}, {}, [10]) (10)});next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = nulo, this.data_type = 2, this.adler = 0} b.exports = d}, {}]}, {}, [10]) (10)});next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = nulo, this.data_type = 2, this.adler = 0} b.exports = d}, {}]}, {}, [10]) (10)});
